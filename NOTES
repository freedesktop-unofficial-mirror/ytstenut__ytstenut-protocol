[[These are personal notes on the protocol, pushed into the repo only for back
up purposes -- NOTHING HERE IS NOT SUBJECT TO REVISION, you have been warned.]]

Introduction
============

Users often carry out similar activities on different devices (e.g., watch
videos on a smart phone, laptop, TV) but as the user moves in time and space,
the optimal choice of a device for any given activity might change (a smart
phone might be the optimal video viewing platform while travelling on a train,
but TV might be optimal in the comfort of one's living room).

The nScreen framework aims to facilitates seamless transition of the user's
activities as she moves around. It does so by providing a communication channels
through which individual user-facing applications on distinct devices can
cooperate and coordinate their discrete behaviours, and in so construct a
dynamic and homogenous experience spanning the devices involved.

The activities for which consumers use computers are impossible to enumerate,
and are set to evolve. Consequently the nScreen framework does not seek to
narrowly define the activities and/or services that might fall withing its
scope, nor it seeks to prescribe the ways in which such activities or tasks
should be accomplished. Rather the nScreen framework is a set of generic
protocols and paradigms that can support new activities and services without the
need to modify the core protocols.

More specifically, the aims of the nScreen framework are as follows:

 * To provide unified discovery, connection and transport mechanism that could
   be utilised on a variety of hardware and software platforms by a wide
   spectrum of user-facing applications,

 * To provide means for transmitting metadata describing user-oriented
   activities, and doing so in secure manner protecting user privacy,

 * To provide standard metadata definitions for most common user-facing
   activities, so as to allow common classes of applications to inter-operate
   without having to know anything about the implementation details of their
   nScreen partners.


The nScreen use cases fall into two broad categories:

 * subscription-based, server-centered services,

 * server-less application interaction within a home cloud.

The nScreen framework aims to support both of these scenarios in a transparent
manner.

nScreen applications can be divided into two broad classes: task-oriented
applications (such as nScreen enabled video players, etc.) and control
applications. The latter provide background nScreen service on an
nScreen-enabled devices, allowing, for example, spawning of suitable
task-oriented applications on the device in response to incoming requests. In
addition, control applications coupled with a suitable UI can be used as generic
nScreen remote controls.

The remainder of this document is divided into two parts: part I describes the
protocols that define the nScreen communication backbone, while part II
describes the metadata model.


Part I. nScreen Communication protocols
=======================================

The nScreen communication protocols are built on the existing XMPP (aka
'jabber') standard. The reasons for choosing XMPP as basic transport protocol
are:

 1. Using an established standard such as XMPP means that much of the wheel
    needs not to be reinvented,

 2. XMPP is supported on a broad range of hardware and software platforms, thus
    aiding the speed with which the nScreen framework can be rolled out,

 3. XMPP is an open standard that can be used without difficulties over
    licensing,

 4. XMPP is extensible by design,

 5. XMPP is capable of operating both in a server-based and server-less
    manner, and supports both of these modes a transparent way,

 6. XMPP is XML-based, so that implementation of extensions is simplified by
    being able to use standard XML-processing tools, such a parsers, etc.


The nScreen framework defines three extensions to XMPP:

 1. PKI-driven authentication and subscription that provides for identity
    verification and subscription policy enforecement at the client end, and
    facilitates secure client-to-client communication, [[Need to nail down this
    bit -- best define it so we can implement without the PKI to start with]]

 2. Mechanism for exchanging of nScreen metadata, including protocols for
    private messaging,

 3. A serverless protocol similar to that defined by XEP-0174
    (http://xmpp.org/extensions/xep-0174.html), but reserved for nScreen use.


Security and Privacy Considerations
-----------------------------------

The flexible and extensible nature of the nScreen framework means that it is not
possible to predict what kind of data my be transmitted via the protocol in its
real-world deployment. Furthermore, the expectation of deployment on variety of
platforms, ranging from desktop computers to mobile phones, means that multiple
implementations of the protocol will be in use. It is, therefore, paramount that
security and privacy of user data is a key factor in the design of the protocol
itself. From this, the following key principles follow:

 1. The protocol must facilitate complete privacy of data in transit, preventing
    evesdropping anywhere along the line of transit,

 2. Reliable identity verification mechanism must be available through the
    protocol itself, and must work both in server and serverless context,

 3. The protocol must provide structured access control to user's local
    resources that will work both for server-based and server-less setups.


These three principles have the following implications:

 1. client-to-client encryption protocols need to be set up for transmission of
    sensitive data, in particular, it should be noted that:

    * xmpp on its on only provides client-to-server privacy, and as such is
      susceptible to server evesdropping,

    * normal xmpp presence information is broadcast accross all subscribed
      contacts, which might not be appropriate for certain types of data that
      might be included in nScreen extended status message.

 2. A client-end authentication model is needed to ensure genuine access control
    for user's resource. This is an absolute requirement for server-based
    service deployment, but is desirable that this functionality is available
    also in the local, serverless, setup (i.e., allowing a visiting friend
    access to home wifi should not automatically imply access to any nscreen
    services).


Section I.1: nScreen Subscription and Authentication protocols
--------------------------------------------------------------

Section I.1.1: nScreen Subscription
-----------------------------------

XMPP provides a server-centric subscription mechanism; the nScreen framework,
however, requires subscription mechanism that will (a) work both for
server-driven and server-less connections, and (b) ensure that the end-user,
rather than the server provider, maitains access control to their own local
resources.

The subscription protocol, described further on, is closely tied to a format of
application JID, which will be described first.


I.1.1.1 nScreen JID form
------------------------

A fully qualified JID (jabber id) identifies a single participant in the nScreen
mesh. As in standard XMPP, a fully qualified JID consists of a bare JID and a
resource identifier; the bare JID identifes a user, while a fully qualified JID
identifies a single connection by that user to the nScreen mesh (multiple
simultaneous connections by single bare jid are allowed for obvious reasons). An
example of a bare JID would be 'someone@somewhere.com' while a fully qualified
JID would be 'someone@somewhere.com/myresource'

In the remainder of this document, the term 'JID' is used to refer to bare JIDs;
if a fully qualified jabber id is meant, this will always be explicitely stated.

nScreen JIDs fall into three broad categories: JIDs for outward (customer)
facing services offered by service providers, inward facing JIDs used to
identify customers to service providers, and JIDs used for serverless
connectinons in a home cloud.


 I.1.1.1.1 Outward-facing JIDs
 .............................

  * The canonical form of an outward-facing jid is
    'application.subdomain.domain@service-provider', and reflects the notional
    structuring of the nScreen mesh. This form of jid must be used for all
    outward facing connections.

  * The principal reason for this structuring is to facilitate a uniform feel
    for customer facing UIs regardless of application or service provider:
    client side implementations of the nScreen specification are expected to
    organise their connection rosters using this 4 tier scheme.

  * As with normal xmpp JIDs, the service-provider part of the JID (the part
    after the @ symbol) must be an Internet domain name that can be resolved
    through a DNS service,

  * Service providers are free do define the domains and subdomains in a way
    that fulfills their specific needs, for example, an 'easymart.com' provider
    could define per-store domains and per-department subdomains:

      .menswear.broadway-store@easymart.com

  * The lefmost part of the JID must identify the individual application that
    is providing the service in question,

  * Multiple connection by single application are differentiated by the resource
    id of the fully qualified JID.


 I.1.1.1.2 Inward-facing JIDs
 ............................

  * Inward facing JIDs are used to identify customer connections to a service
    provider; no special restrictions beyond those specified by the core XMPP
    protocol are placed on these by the nScreen specification.


 I.1.1.1.3 Serverless JIDs
 .........................

  * Serverless JIDs are used for serverless connections inside home cloud (i.e.,
    running over the local-nscreen protocol specified later in this document).

  * Serverless JIDs are outward-facing JID's without the service-provider part,
    i.e., they have the form 'application.device.domain'.

  * The device part of the JID should be obtained automatically using a suitable
    mechanism (such as the host name); this is to ensure that all applications
    running on the same physical device use the same 'device' id.

  * The domain part of the JID should identify the home cloud. (Though the
    present version of the specification does not provide for serverless
    connections that cross the cloud boundary, such mechanism might be added
    in future versions.)

  * Multiple connections by the same application are differentiated by the
    resource id.


I.1.1.2 Server-end subscription
-------------------------------

nScreen subscription services operated through an nscreen xmpp server are built
around normal xmpp subscription mechanisms as specified by the core xmpp
protocol (RFC 3920, http://tools.ietf.org/html/rfc3920), and nScreen servers
should comply with the subscription policies this specification sets out.

Available outward facing application should be advertised by the server via xmpp
pubsub mechanims (XEP-0060, http://xmpp.org/extensions/xep-0060.html).


I.1.1.3 Local Subscription
--------------------------

[[I suspect this is the biggest departure from the normal workings of xmpp.]]

Server-end subscription cannot be relied upon to provide adequate access control
to resources owned by a given user, since it is ultimately controlled by the
service provider, not the user; in order to avoid situations such as users'
rosters flooded by unwanted applications that they do not wish to interact with
(even if from well-meaning vendors), additional local subscription mechanism is
used to control incoming traffic.

Similarly, there is a need for access control mechanism when operating within a
server-less cloud, so as to avoid equating connection to the cloud with blank
access to all nScreen services. This local subscription mechanism facilitates
such finer grained access control in server-less setup.


Overview
........

 * Since the local subscriptions only control incoming traffic, there are only
   three subscription states:

   - 'Yes'  : communication enabled,
   - 'No'   : remote client barred from communiting with local client,
   - 'Unset': initial value

 * The meaning of the 'Unset' value is controlled by local policy; the user
   might choose 'Unset' to mean 'No', or she might choose 'Unset' to mean
   'allow remote initiation of new subscriptions'.

 * Per sub-domain, domain and service-provider subscription is possible, i.e.,
   the user can subsribe to (or block) all applications by particular service
   provider, or all applications in a particular domain of a specific service
   provider.

 * The subscription database is queried from more complete subscriptions toward
   broader subscription classes. An example subscription database for online
   store application on a phone of a specific user could look like:

        mens-wear.easymart.com      | Yes
        ties.mens-wear@easymart.com | No

   Meaning, the local user is happy to interact with applications in the
   mens-wear domain of easymart.com, except applications in the ties
   subdomain. Depending on the local policy, the user might either want all
   subscriptions requests from easymart.com rejected (implicit 'No') or
   presented for examination.


Local subscription and presence
...............................

In the following P is an nscreen application on a user end device (e.g., a
mobile phone), M is a shop checkeout application, with jid
'checkoutapp.checkout1.old-inns-service-station@easymart.com'. When M is offered
for addition into the roster of P by the connection manager, the following
subscription check is carried out before user is made aware of M:

     A. P checks subscription database for M's complete (but bare) jid:

         Yes:   P proceeds to 2 (Identity verification),
         No:    P removes M from roster and ignores any further messages from M,
         Unset: P proceeds to next step,

     B. P continues to check the subscription database for partial jids by
        removing progressively more jid elements (e.g.,
        checkout1.old-inns-service-station@easymart.com, then
        old-inns-service-station@easymart.com, then easymart.com) using the
        algorithm described in (A) until the final test on service-provider:

         Yes:   P proceeds to 2 (Identity verification),
         No:    P removes M from roster and ignores any further messages from M,
         Unset: P checks whether local policy allows automatic subscription
                initiation:

                  Yes: proceeds 3 (New subscription),
                  No : P removes M from roster and stops processing; any further
                       advances by M will be silently ignored.

  2. Identity verification:

     See Section I.2.

  3. New subscription

     A. P asks user if she wishes to allow M to cooperate with P

	No : P sets the P <-> M subscription in local database to 'No'
             P removes M from P's roster and stops processing,

	Yes: P proceeds to 2 (Identity verification)



Section I.1.2: nScreen identity verification
--------------------------------------------

[[TODO -- this is not of critical importance for the local cloud use, but
essential for the server-based use, and as such must be specified here in a
reasonably workable fashion, even though we are unlikely to be implementing this
in the initial roll out. XEP-0116 (http://xmpp.org/extensions/xep-0116.html)
looks very much like what we need, but it has defferred status, so not sure
what's the best thing to do here (want to avoid reinventing the wheel).]]


Section I.1.3: nScreen privacy protocols
----------------------------------------

The nScreen protocol specifies two sets of features aiming to ensure privacy of
user data: the use of TLS and the use of end-to-end encryption. TLS layer
facilitates private client-to-server and server-to-server data exchange. It does
not, however, prevent evesdropping by a server involved in data transmission. As
such, TLS provides sufficient protection only for low risk data. Clients wishing
to transmit high risk data (e.g., banking details and such) must either secure
the server (i.e., ensure no server hops are involved and no sensitive data is
leaked in the presence information), or, preferrably make use of end-to-end
encryption in additon to TLS.


Section I.1.3.1: TLS
--------------------

Complient nScren applications, both server and clients, must support TLS as
specified by the core XMPP protocol (RFC 3920,
http://tools.ietf.org/html/rfc3920), and must use TLS secured connections
exclusively, both for client-to-server and server-to-server connections; both
complient servers and clients are required to refuse connections that do not use
TLS.


Section I.1.3.2: End to end encryption
--------------------------------------

The end-to-end encryption to be used by nScreen clients is described by the xmpp
extension xep-e2e (RFC 3923, http://tools.ietf.org/html/rfc3923). [[Ideally,
some form of e2e TLS channel for exchange of presence and messages would be
preferrable, but the xep-e2e will do in principle; we are unlikely to be
implementing this initially anyway.]]


Section I.2: local-nscreen protocol
-----------------------------------

The local-nscreen protocol allows for automatic connection between nscreen
clients running on the same LAN. It is derived from, and nearly identical to,
the local-xmpp protocol, but with some changes:

  * The service is called 'nscreen' rather than 'presence', i.e., the PTRs have
    pattern 'JID._nscreen._tcp._local.',

  * connection is done by jid and resource as with regular xmpp, the machine
    part (after @) is worked out automatically,

  * The TXT record contains an extra entry 'nstat' that holds the
    <nscreen:status> output as a single like, [[this has to be suitably encoded
    to ensure we comply with the DNS-SD size limits -- for the whole TXT record
    200 is recommened maximum, 400 is acceptable, and 1300 is the absolute
    maximum allowed); we should aim here not to exceed the 400 limit]].

  * The TXT record also holds extra entries 'napp','ndev', 'ndom'
    with human-readable descriptions of the application,
    device and domain [[in the server context we use vCard for this, though
    we have to redefine the standard meaning of the vCard fields, since those,
    were intended to describe humans; this needs addressing elsewhere]]

    [[I think it should be possible to implement these difference as an
    --nscreen command line option to salut, really]]


Part II: nScreen Messaging
==========================

[[This is the upper layer of the nscreen protocols; this is the one bit we have
a fairly good idea what we want to do -- we already have a working
proof-of-concept implementation of libnscreen on the top of telepathy working
along these lines; except we do not use xml for the messages but use specially
crafted strings inside normal presence and im messages.]]

The purpose of the nscreen protocols is to allow applications to exchange
metadata that would allow them to coordinate their activity across multiple
devices; the protocol does not aim to provide mechanisms for actual data
transfers, though in some common and specific cases it mandates which other
standard protocols should be used, see Section II.3.

The messaging consists of two basic building blocks: extended status information
and instruction messages. Message of either type is conceptually a data tupple
describing an activity in terms of a subject (capability in use), verb (the
activity itself) and set of attributes (what and how). The primary difference
between the two types of messages is in the tense: status message describe a
present state, while instruction messages refer to a desired future state.

In order to facilitate communication between common application classes, the
protocol defines the subjects, verbs and attributes for common user
activities. At the same time, new subjects, verbs and attributes can be defined
and used by specialized applications.

(NB: DTD is in Appendix A.)


Section II.1: Extended Status
-----------------------------

Extened status information is encapsulated in <nscreen:status> element embedded
inside xmpp <presence> stanza. The status element holds an unspecified number of
<nscreen:capability> elements that describe status for each capability the
client supports. [[TP API will be needed to access this; does not have to be too
complex, even being able to retrieve the <nscreen:status> xml snipped for local
processing would be sufficient, e.g., something like GetPresenceStanzaPart
(const char *name) that would be called as GetPresenceStanzaPart
("nscreen:status").]]

The <nscreen:capability> element can be extended with custom attributes;
however, no frequently changing information (such as current playback position)
is permited as part of status to avoid flooding of the network.


Status XML examle
-----------------

<nscreen:status version='1.0' primary-capability='ns-caps-video'>
  <nscreen:capability type='ns-caps-video'
                activity='ns-activity-play'
                uri='some random youtube url'
                volume='0.75'>
    [Description]
  </nscreen:capability>
</nscreen:status>


Section II.2: Instruction Messages
----------------------------------

Instruction messages are used to send nscreen commands. The protocol defines a
set of generic xml elements that are used to encapsulate nscreen messages, with
parameters transmitted via xml attributes.


Message Transport
.................

[[The are multiple options here, including: (a) use <iq> stanzas with suitable
nscreen namespace; (b) insert <nscreen:message> into <message> stanza on the
same level as <body>; (c) use ad-hoc commands as per XEP-0050,
http://xmpp.org/extensions/xep-0050.html (NB: jabber-rpc is not suitable,
because the RPC arguments for each call are fixed in number and position.)

(a) is probably the least efficient way of doing this, I can see no obvious
advantages, and would need a whole API/interface for these IQs.

(b) would really just need API to retrive the <nscreen:message> xml snipped out
of the message as per the extended status information.

(c) has the advantage of predefined capability discovery mechanism (though this
could easily be added alongside (b)), the multi-stage processing it facilitates
might add extra flexibility making everything bit more future proof, and bulk of
the mechanism would be nscreen-agnostic, with the extension being limited to
defining the payload. BUT, there seems to be no API in telepathy for this at the
moment, so that would require implementing this whole stack (also, how well is
xep-0050 supported outside of telepathy, i.e., we are looking for non-telepathy
deployment, and exessive work required could slow this down).

So, (c) seems like the ideal solution, the big question is how much effort is
needed; I don't think Telepathy currently supports this.]]


Message Format
..............

The top level message element is <nscreen:message> with the following required
attributes:

  * version: the nscreen protocol version,

  * type:    the message type (see below and the DTD),

  * time:    time of message dispatch, expressed according to ISO 8601, with
             at least millisecond precission.


Message types
-------------

The following types of messages are defined:

command:  a command sent from app A to app B to executed directly by app B; the
          message payload is held by a <nscreen:command> element.

transfer: request by application A to application B to transfer B's activity to
	  application C; the message payload is held by <nscreen:transfer>
	  element.

find:     request by app A to a control app C to identify suitable app B to
          dispatch a command to. The message payload uses <nscreen:transfer>
          element.  Rationale: because of the need to facilitate e2e encryption,
          commands cannot be proxied through control applications; the Find
          request allows clients to initiate a transfer to an application that
          might not yet be running on the target device (i.e., C will take care
          of spawning a suitable client if one is not available).

found:    reply by control application C to application B in response to earlier
          find request. This is similar to a Transfer request, but is only
          generated in response to previous Find request; the <transfer> element
          is used for the payload of this reply.


Message time
------------

The message dispatch time must have at least milliscond precission; consequently
all nScreen capable devices are required to keep local clock accurate to a
degree necessary to generate time stamps with the required accuracy.


Command example
---------------

The following xml snippet tells some other application to start playing given
video starting 3/4 into the video duration:

<nscreen:message type='command' version='1.0' time='1970-01-01T00:00:00.000Z'>
  <nscreen:command capability='ns-caps-video'
                   activity='ns-activity-play'
                   uri='some random youtube url'
                   progress='0.75'>
        [Optional command data; binary data base64 encoded]
      </nscreen:command>
</nscreen:message>


Section II.3: Definition of common metadata classes
---------------------------------------------------

The cannonical definition is given by the DTD (see Appendix A); the following
information is extracted from the DTD for convenience.


Section II.3.1: Common capability classes
.........................................

ns-caps-audio: audio playback capabilities

ns-caps-video: video playback capabilities

ns-caps-image: image display capabilities

ns-caps-html: html rendering capabilities

ns-caps-control: control application

[[ TODO -- more stuff should be added here ]]

Custom capabilities can be defined, providing these are suitably namespaced with
a custom prefix; custom capabilities must not use 'ns-' prefix.


Section II.3.1: Common activity classes
.......................................

Absence of the 'activity' attribute, or its empty value imply idle state.

ns-activity-play: playback

ns-activity-pause: paused state

ns-activity-ffw: fast forward

ns-activity-rwd: rewind

ns-activity-volume: volume adjustment

[[ TODO -- more stuff should be added here ]]

Custom activities can be defined, providing these are suitably namespaced with
a custom prefix; custom activities must not use 'ns-' prefix.


Section II.3.1: Common attributes
.................................

uri: uri a of a resource associated with activity

uid: uid identifying resource associated with activity [[The idea is being able
to use something like, for example, musicbrainz id to identify the resource,
though in practice this might be hard to extend beyond audio]]

volume: volume level (floating point number from <0,1>)

progress: activity progress (floating point number from <0,1>; this is the
          preferred way of passing information such as stream position.

position: activity position (floating point number); NB: applications should
          use the 'progress' attribute whenever possible instead of 'position'.

description: human readable description, suitable for presentation to user

jid: jabber id; primarily for use by messages with 'transfer' payload

speed: speed of activity (floating point number; 1.0 indicates 'normal' speed)


Custom attributes can be defined, providing these are suitably namespaced with
a custom prefix; custom attributes must not use 'ns-' prefix.


Section II.4: Data Transfer Protocols
-------------------------------------

This section defines standard data transfer protocols to be used by nScreen
clients; this list does not restrict clients to these protocols alone, but
sets out preferred protocols.


Section II.4.1: File Transfers
------------------------------

 * The preferred file transfer protocol is XEP-0096,
   http://xmpp.org/extensions/xep-0096.html; this protocol must be supported by
   all complient nScreen clients.

 * It is recommended that clients also implement XEP-0234,
   http://xmpp.org/extensions/xep-0234.html, (Jingle File Transfer); this
   protocol is currently in experimental stage, but once it is reaches the draft
   stage, it will be adopted as the default file transfer protocol for nScreen
   clients. [[This has relatively limited practical impact on us, the initial
   deployment will be Telepathy based, which presumably will hide this
   disctinction from us.]]


[[TODO -- we should recommend protocols for data streaming, and specifically
mandate preferred protocols for streaming of video and audio in the manner we
mandate the File Transfers. Presumably around XEP-0166,
http://xmpp.org/extensions/xep-0166.html, (Jingle).]]


Appendix A: nScreen DTD
=======================

<?xml version='1.0' encoding='UTF-8'?>

   <xs:schema
       xmlns:xs='http://www.w3.org/2001/XMLSchema'
       targetNamespace='nscreen'
       xmlns='nscreen'
       elementFormDefault='qualified'>

     <xs:import namespace='jabber:client'/>

     <xs:element name='message'>
        <xs:complexType>
           <xs:sequence>
             <xs:choice minOccurs='1' maxOccurs='1'>
               <xs:element ref='command'/>
               <xs:element ref='transfer'/>
             </xs:choice>
           </xs:sequence>

           <xs:attribute name='type'
                         type='xs:NMTOKEN'
                         use='required'>
             <xs:simpleType>
               <xs:restriction base='xs:NCName'>
                 <xs:enumeration value='command'/>
                 <xs:enumeration value='transfer'/>
                 <xs:enumeration value='find'/>
                 <xs:enumeration value='found'/>
               </xs:restriction>
             </xs:simpleType>
	   </xs:attribute>

           <xs:attribute name='version'
                         type='xs:string'
                         use='required'/>

           <xs:attribute name='time'
                         type='xs:dateTime'
                         use='required'/>

           <xs:attribute name='target'
                         type='xs:string'
                         use='optional'/>

        </xs:complexType>
     </xs:element>

     <xs:element name='command'>
       <xs:complexType>
         <xs:simpleContent>
           <xs:extension base='xs:string'>
             <xs:attribute name='capability'
             		   type='xs:NMTOKEN'
                           use='required'/>
             <xs:attribute name='activity'
                           type='xs:NMTOKEN'
                           use='required'/>
             <xs:attribute name='uri'
                           type='xs:anyURI'
                           use='optional'/>
             <xs:attribute name='uid'
                           type='xs:string'
                           use='optional'/>
             <xs:attribute name='progress'
                           type='xs:double'
                           use='optional'>
	       <simpleType>
  	         <restriction base='double'>
	           <minInclusive value='0.0'/>
    	           <maxInclusive value='1.0'/>
  	         </restriction>
	       </simpleType>
	     </xs:attribute>

             <xs:attribute name='position'
                           type='xs:double'
                           use='optional'/>
             <xs:attribute name='jid'
                           type='xs:string'
                           use='optional'/>
             <xs:attribute name='device'
                           type='xs:string'
                           use='optional'/>
	     <xs:anyAttribute namespace='##other'/>
           </xs:extension>
         </xs:simpleContent>
       </xs:complexType>
     </xs:element>

     <xs:element name='transfer'>
       <xs:complexType>
         <xs:simpleContent>
           <xs:extension base='xs:string'>
             <xs:attribute name='capability'
             		   type='xs:NMTOKEN'
                           use='required'/>
             <xs:attribute name='to'
             		   type='xs:string'
                           use='optional'/>
           </xs:extension>
         </xs:simpleContent>
       </xs:complexType>
     </xs:element>

     <!-- included inside <presence></> -->
     <xs:element name='status'>
        <xs:complexType>
           <xs:sequence>
             <xs:choice minOccurs='1' maxOccurs='1'>
               <xs:element ref='encrypted-content'/>
             </xs:choice>
           </xs:sequence>

           <xs:attribute name='version'
                         type='xs:string'
                         use='required'/>
           <xs:attribute name='primary-capability'
                         type='string'
                         use='required'/>
        </xs:complexType>
     </xs:element>

     <xs:element name='capability'>
       <xs:complexType>
         <xs:simpleContent>
           <xs:extension base='xs:string'>
             <xs:attribute name='type'
                           type='xs:NMTOKEN'
                           use='required'/>
             <xs:attribute name='activity'
                           type='xs:NMTOKEN'
                           use='optional'
		           default='ns-activity-idle'/>
             <xs:attribute name='uri'
                           type='xs:anyURI'
                           use='optional'/>
             <xs:attribute name='uid'
                           type='xs:string'
                           use='optional'/>
             <xs:attribute name='volume'
                           type='xs:double'
                           use='optional'>
	       <simpleType>
  	         <restriction base='double'>
	           <minInclusive value='0.0'/>
    	           <maxInclusive value='1.0'/>
  	         </restriction>
	       </simpleType>
	     </xs:attribute>
	     <xs:anyAttribute namespace='##other'/>
           </xs:extension>
         </xs:simpleContent>
       </xs:complexType>
     </xs:element>
  </xs:schema>
