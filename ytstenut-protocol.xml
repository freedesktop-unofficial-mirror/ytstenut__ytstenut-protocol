<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:xlink="http://www.w3.org/1999/xlink"
	 xml:id="ytstenut-protocol" xml:lang="en" class="specification"
	 status="draft">
  <info>

    <title>Ytstenut Protocol Specification</title>
	<subtitle>Version 0.2</subtitle>

	<org>
	  <orgname>Intel Corporation</orgname>
	  <orgdiv>Open Source Technology Centre</orgdiv>
	</org>

    <author>
      <personname>
	<firstname>Tomas</firstname> <surname>Frydrych</surname>
<!--
      <affiliation>
        <orgname>Intel Corporation</orgname>
      </affiliation>
-->
      </personname>
      <email>tf@linux.intel.com</email>
    </author>

    <revhistory>
<!--
      <revision>
         <revnumber>0.1</revnumber>
         <date>22 October 2010</date>
         <revremark>Initial draft</revremark>
      </revision>
      <revision>
         <revnumber>0.2</revnumber>
         <date>27 October 2010</date>
         <revremark>
	   responding to comments from Will Thompson (Collabora)
	 </revremark>
      </revision>
      <revision>
         <revnumber>0.3</revnumber>
         <date>29 October 2010</date>
         <revremark>
	   tidying up loose ends
	 </revremark>
      </revision>
-->
      <revision>
         <revnumber>0.4</revnumber>
         <date>1 November 2010</date>
         <revremark>
	   Initial draft
	 </revremark>
      </revision>
      <revision>
         <revnumber>0.5</revnumber>
         <date>29 November 2010</date>
         <revremark>
	   Changed JID specification; use XEP-0050 as messaging backbone
	 </revremark>
      </revision>
    </revhistory>

    <copyright>
      <year>2010</year>
      <holder>Intel Corporation</holder>
    </copyright>
  </info>

<?hard-pagebreak?>

  <section xml:id="intro">
    <title>Introduction</title>
    <para>
      We often carry out similar activities on different devices, e.g., watch
      videos on a smart phone, laptop, or a TV set. However, as we move in time
      and space, the optimal choice of a device for any given activity might
      change: a smart phone might be the optimal video viewing platform while
      travelling on a train, but a TV set might be preferred in the comfort of
      one's living room.
    </para>

    <para>
      Furthermore, our discrete activities are often interconnected even when
      distributed across distinct devices: a person watching a video on TV might
      want to locate an additional information about the video itself (e.g.,
      about the leading actor, director, special effects, etc.), and might use a
      smart phone, rather than the TV, to retrieve this information.
    </para>

    <para>
      The above examples illustrate two key aspects of human interaction with
      today's technology: (a) our activities are no longer confined to a single
      dedicated device each, but are distributed over a device mesh, and (b) the
      mesh as a whole now provides a context which shapes the activities
      themselves.
    </para>

    <para>
      Unfortunately, the technologies of today neither allow for our experience
      to stretch seamlessly over the device mesh, nor provide an easy access to
      the unified activity context the device mesh represents.  What device
      meshing technologies there already are (e.g., UPnP), tend to focus
      narrowly on the sharing of hardware resources. While resource sharing is
      an important capability of the device mesh, on it's own it only provides a
      quantitative, rather than qualitative, improvement on the overall user
      experience (e.g., the ability to use a TV set to watch a video
      stored on a PC does not represent a radical improvement on using a memory
      stick to achieve the same).
    </para>

    <para>
      A radical improvement of the user experience requires to move focus from
      hardware to the user activities, and to start thinking in terms of
      interacting with, and transferring, the user activities per se; and since
      user activities are generally mapped directly to user facing applications,
      what is needed is not just a device mesh, but rather an application
      mesh. This mesh must facilitate both active interaction as well as passive
      mutual awareness between applications (for the activity context is
      constantly changing). Such a mesh would enable applications to cooperate
      and coordinate their discrete behaviours, and in doing so construct a
      dynamic and homogeneous experience spanning the devices involved.
    </para>

    <para>
      The Ytstenut framework aims to facilitate the creation of a such a dynamic
      application mesh. It does so by providing a communication channels through
      which individual user-facing applications on distinct devices can
      passively advertised their activities in real time, and actively cooperate
      and coordinate their discrete behaviours, and in so construct a dynamic
      and homogeneous experience spanning the devices involved.
    </para>

    <para>
      The activities for which consumers use computers are impossible to
      enumerate, and are set to evolve. Consequently the Ytstenut framework does
      not seek to narrowly define the activities and/or services that might fall
      withing its scope, nor it seeks to prescribe the ways in which such
      activities or tasks should be accomplished. Rather the Ytstenut framework
      is a set of generic protocols that can support new activities and services
      without the need to modify the core protocols.
    </para>

    <para>
      More specifically, the aims of the Ytstenut framework are as follows:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  To provide unified discovery, connection and transport mechanism that
	  could be utilised by user-facing applications running on a variety of
	  hardware and software platforms,
	</para>
      </listitem>

      <listitem>
	<para>
	  To provide standardised metadata model to facilitate efficient
	  inter-application communication,
	</para>
      </listitem>

      <listitem>
	<para>
	  To provide mechanisms for both active interaction between
	  applications, and passive awareness of each other.
	</para>
      </listitem>
    </itemizedlist>

    <section xml:id="intro-usecases">
      <title>Service Models</title>

      <para>
	Ytstenut services fall into two broad categories:
      </para>

      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Subscription-based services: these are provided by discrete
	      entities, each operating their own Ytstenut server. Ytstenut users
	      connect to this server using credentials agreed with the service
	      provider, and interact with applications offered by the service
	      provider through their server.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Applications interacting within a home cloud: the home cloud use
	      case differs from the subscription service by the absence of a
	      central server; instead the cloud transparently fulfils the role
	      of a subscription-less server.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The Ytstenut framework aims to support both of these scenarios in a
	transparent manner.
      </para>

    </section>

    <section xml:id="intro-application-classes">
      <title>Application Classes</title>

      <para>
	Ytstenut applications can be divided into two broad classes:

	<itemizedlist>
	  <listitem>
	    <para>
	      Task-oriented applications: these are the core participants in the
	      Ytstenut mesh. They are user-facing applications, such as media
	      players, that have been enriched by adding the Ytstenut
	      capabilities.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Control Applications: these provide background Ytstenut services on
	      an Ytstenut-enabled devices. Their principal purpose is to allow
	      task-oriented applications to direct their communications at a
	      device, rather than a specific task-oriented application on that
	      device, and to ensure that appropriate task-oriented application
	      is available (e.g., by spawning of suitable application on the
	      device in response to incoming requests).
	    </para>

	    <para>
	      While control applications can be purely background processes,
	      when provided with a suitable UI they can be used as generic
	      Ytstenut remote controls.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </section>

    <section xml:id="intro-metadata">
      <title>Metadata model</title>

      <para>
	One of the key components of the Ytstenut framework is the metadata
	model. The purpose of the Ytstenut protocols is to allow applications to
	exchange metadata describing their activities in a way that would allow
	them to coordinate these across multiple devices and
	platforms. Consequently, the metadata model must be:

	<itemizedlist>
	  <listitem>
	    <para>
	      Flexible and extensible, to allow use with new, innovative
	      applications,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Sufficiently standardised to allow common classes
	      of applications to talk to each other transparently.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	It is worth noting that the protocol does not aim to provide mechanisms
	for actual data transfers, though in some common and specific cases it
	mandates which other standard protocols should be used (see <xref
	linkend="messaging-data-transfer"/>).
      </para>

      <para>
	The Ytstenut metadata is modelled as a pairing of a capability subject
	(representing a single application feature that is of interest to a
	user) and an activity predicate (a way in which the user can manipulate
	content tied to a specific capability). Both the capability and the
	activity in each specific pair can be further qualified by attributes;
	the resulting <code>{capability, activity, attributes}</code> tuple
	constitutes the elementary unit of Ytstenut metadata.
      </para>

      <para>
	The above described tuple is used in two distinct ways: to indicate
	present application state, and to encapsulate instructions about future
	desired state.
      </para>

      <para>
	In order to facilitate communication between common application classes,
	the protocol defines the subjects, verbs and attributes for common types
	of user activities. At the same time, new subjects, verbs and attributes
	can be defined and used by specialised applications.
      </para>

      <para>
	In addition to the metadata describing application activities, the
	protocol also specifies means through which application describe
	themselves to the user.
      </para>
    </section>

    <section xml:id="intro-xmpp">
      <title>XMPP backbone</title>

      <para>
	The Ytstenut communication protocols are built on the existing XMPP
	standard. The reasons for choosing XMPP as the basic transport protocol
	are:

	<itemizedlist>
	  <listitem>
	    <para>
	      Using an established messaging standard means that much of the
	      wheel needs not to be reinvented,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is supported on a broad range of hardware and software
	      platforms, thus aiding the speed with which the Ytstenut framework
	      can be rolled out,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is an open standard that can be used without difficulties
	      over licensing,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is extensible by design,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is capable of operating both in a server-based and
	      server-less manner, and supports both of these modes a in
	      transparent way,
	    </para>
	  </listitem>


	  <listitem>
	    <para>
	      XMPP is XML-based, so that implementation of extensions is
	      simplified by being able to use standard XML-processing tools,
	      such a parsers, etc.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	As far as possible, the Ytstenut framework aims to reuse existing XMPP
	capabilities and features; these are augmented by two extensions:

	<itemizedlist>
	  <listitem>
	    <para>
	      Protocols for encoding of Ytstenut metadata,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A server-less protocol similar to link-local XMPP<citation><xref
	      linkend="xep0174"/></citation> , but tailored for Ytstenut use.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	In addition, at number of points, the Ytstenut specification mandates
	the use of standard, but optional, XMPP features, particularly so, where
	this is desirable to improve security and privacy.
      </para>
    </section>
  </section>

  <?hard-pagebreak?>

  <section xml:id="security">
    <title>Security and Privacy Considerations</title>

    <para>
      The flexible and extensible nature of the Ytstenut framework means that it
      is not possible to predict what kind of data may be transmitted via the
      protocol in its real-world deployment. Furthermore, the expectation of
      deployment on a variety of platforms, ranging from desktop computers to
      mobile phones, means that multiple implementations of the protocol will be
      in use. It is, therefore, important that security and privacy of user data
      is a key factor in the design of the protocol itself. More specifically:

      <itemizedlist>
	<listitem>
	  <para>
	    The protocol must facilitate privacy of data in transit where that
	    is appropriate or required,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Reliable identity verification mechanism must be available,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The protocol must provide structured access control to user's
	    local resources.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      With regards to the above, the following should be noted in particular:

      <itemizedlist>
	<listitem>
	  <para>
	    XMPP on its on only provides client-to-server privacy. As such XMPP
	    exchanges that span multiple servers are susceptible to server
	    eavesdropping; the practical implications of this are addressed in
	    <xref linkend="comm-protocols-privacy"/>,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Normal XMPP presence information is broadcast across all subscribed
	    contacts, or, in the case of link-local XMPP protocol, even
	    advertised entirely openly via m-DNS broadcasts; consequently the
	    protocol avoids using the presence mechanism for metadata
	    exchanges, including the extended status information (see <xref
	    linkend="messaging-status"/>).
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      The Ytstenut protocol specifies two sets of features aiming to ensure
      privacy of user data: the use of TLS (see <xref
      linkend="comm-protocols-privacy-tls"/>), and the use of end-to-end
      encryption (see <xref linkend="comm-protocols-privacy-e2e"/>).
    </para>

  </section>

<?hard-pagebreak?>
  <section xml:id="comm-protocols">
    <title>Communication Backbone Protocols</title>

      <section xml:id="comm-protocols-jid">
	<title>Ytstenut JID</title>

	  <annotation role="comment">
	    <info>
	      <authorinitials>tf</authorinitials>
	      <orgname>Intel</orgname>
	    </info>
	    <para>
	      This section is under further review; we are looking into ways of
	      sharing a connection (i.e., a JID) between applications on the
	      same device.
	    </para>
	  </annotation>

	<para>
	  All Ytstenut participants, whether running in server-based or
	  server-less context, are identified by an XMPP JID<citation><xref
	  linkend="rfc3920"/></citation>. The bare JID identifies the (human)
	  user, while the resource part of a fully qualified JID is used to
	  identify the application: <code>user@somewhere/application</code>.
	</para>

	<para>
	  In the remainder of this document, the term <code>JID</code> is used
	  to refer to fully qualified JIDs; if a bare JID is meant, this will
	  always be explicitly stated.
	</para>
      </section>

      <section xml:id="comm-protocols-authentication">
	<title>Authentication</title>

	<para>
	  Authentication is accomplished via SASL per core XMPP protocol
	  (<citation><xref linkend="rfc3920"/></citation>, <citation><xref
	  linkend="rfc2222"/></citation>). SASL authentication must be
	  implemented both for server-based and server-less contexts.
	</para>
      </section>

      <section xml:id="comm-protocols-identity">
	<title>
	  Identity Verification
	</title>

	<section xml:id="comm-protocols-identity-server">
	  <title>Identity Verification in Server-Based Context</title>

	  <para>
	    Standard XMPP does not provide a formal mechanism for identity
	    verification. Because the authentication of two communicating users,
	    <code>A</code> and <code>B</code>, is typically done separately and
	    independently by two different servers, <code>A</code>'s trust in
	    <code>B</code>'s identity implies <code>A</code>'s trust in the
	    authentication procedures of <code>B</code>'s service provider,
	    which cannot be automatically granted.  Therefore, this generic
	    scenario is only acceptable if data exchanged between <code>A</code>
	    and <code>B</code> contains no sensitive information, i.e., for what
	    essentially amounts to an anonymous Ytstenut service.
	  </para>

	  <para>
	    Though there might be numerous Ytstenut applications for which an
	    anonymous service is entirely appropriate, an Ytstenut service that
	    requires reliable identity verification must either implement
	    additional identity verification measures beyond what is specified
	    by the current version of the protocol, or be implemented using a
	    dedicated Ytstenut server that requires direct login, and does not
	    permit server hops (i.e., both <code>A</code> and <code>B</code> are
	    logging into the same server in order to talk to each other). In
	    this situation the service provider is fully in control of the
	    authentication procedure, and, assuming 1:1 mapping between users
	    and their authentication credentials is in place, successful
	    authentication provides also for identity verification.
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-cloud">
	  <title>Identity Verification in Server-Less Context</title>

	  <para>
	    In server-less context of a home cloud, the 1:1 mapping between
	    Ytstenut users and authentication credentials cannot be guaranteed; a
	    simple home cloud set up might, for example, rely on a shared secret
	    to allow applications across the cloud to authenticate, which in
	    turn allows an authenticated application to spoof another
	    application.
	  </para>

	  <para>
	    Although identity spoofing carries with it lesser risks in the
	    context of the home cloud, the following measures are required to be
	    taken by compliant Ytstenut implementations to improve security:

	    <itemizedlist>
	      <listitem>
		<para>
		  Applications must not make assumptions about identity of other
		  Ytstenut participants in the cloud context, unless they
		  implement additional identity verification procedures not
		  specified by the current version of the Ytstenut protocol,
		</para>
	      </listitem>

	      <listitem>
		<para>
		  Applications running both in server-based and server-less
		  contexts must not inject data from server-based streams into
		  the cloud and vice versa.
		</para>
	      </listitem>
	    </itemizedlist>
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-future">
	  <title>Future Expectations</title>

	  <para>
	    Additional identity verification mechanism addressing the current
	    limitations, using technologies such as PKI, will be defined in
	    future versions of the protocol.
	  </para>
	</section>
      </section>

      <section xml:id="comm-protocols-subscription">
	<title>Subscription</title>

	<para>
	  The Ytstenut framework uses a subscription mechanism to provide access
	  control between Ytstenut applications; the details of the subscription
	  mechanism vary between the server-based and server-less modes of
	  operation.
	</para>

	<section xml:id="comm-protocols-server-subscription">
	  <title>Server-end subscription</title>

	  <para>
	    Server-based Ytstenut services must implement standard subscription
	    mechanism as set out by the core XMPP protocol<citation><xref
	    linkend="rfc3920"/></citation> and must comply with the subscription
	    policies the core specification sets out.
	  </para>

	  <para>
	    Available outward facing services to which users can subscribe
	    should be advertised by the server via XMPP Service Discovery
	    mechanism <citation><xref linkend="xep0030"/></citation>.
	  </para>
	</section>

	<section xml:id="comm-protocols-local-subscription">
	  <title>Subscription in server-less context</title>

	  <para>
	    The standard, server-centric, XMPP subscription mechanism is not
	    applicable for the link-local set up; in order to circumvent this
	    limitation, the local-ytstenut protocol specification defined later
	    in this document (see <xref linkend="local-ytstenut"/>), defines a
	    separate subscription mechanism to use in its place.
	  </para>
	</section>

    </section>

    <section xml:id="comm-protocols-privacy">
      <title>Privacy Protocols</title>

      <section xml:id="comm-protocols-privacy-tls">
	<title>TLS</title>

	<para>
	  Compliant Ytstenut applications, both servers and clients, must
	  support TLS as specified by the core XMPP protocol <citation><xref
	  linkend="rfc3920"/></citation>, and must use TLS secured
	  connections exclusively, both for client-to-server and
	  server-to-server connections; both compliant servers and clients are
	  required to refuse connections that do not use TLS.
	</para>

	<para>
	  It should be noted here again that the use of TLS on its own does not
	  prevent server eavesdropping when the XMPP conversation spans multiple
	  servers. Ytstenut applications needing to transmit highly sensitive
	  data should either use single-server XMPP exchanges along the lines
	  described in <xref linkend="comm-protocols-identity-server"/>, or
	  otherwise will have to make use of end-to-end encryption.
	</para>

      </section>

      <section xml:id="comm-protocols-privacy-e2e">
	<title>End to end encryption</title>

	<para>
	  The end-to-end encryption to be used by Ytstenut clients is described
	  by the XMPP e2e extension <citation><xref
	  linkend="rfc3923"/></citation>.

	  <annotation role="comment">
	    <info>
	      <authorinitials>tf</authorinitials>
	      <orgname>Intel</orgname>
	    </info>
	    <para>
	      Ideally, some form of e2e TLS channel for exchange of presence and
	      messages would be preferable, the support for which the XMPP group
	      is looking into<citation><xref
	      linkend="jng-xtls"/></citation>. The xep-e2e will do in principle;
	      it is worth noting that it is unlikely to be used because entities
	      requiring this level of privacy will have to use a dedicated
	      Ytstenut server for identity verification, in which case TLS
	      provides complete privacy of data in transit by virtue of no
	      server hops being involved, thus rendering e2e superfluous.
	    </para>
	  </annotation>

	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="local-ytstenut">
      <title>Link-local Ytstenut protocol</title>

      <para>
	The link-local Ytstenut protocol allows for automatic connection between
	Ytstenut clients running on the same LAN. It is derived from the
	local-xmpp protocol, but with some differences:

	<annotation role="implementation">
	  <info>
	    <authorinitials>wt</authorinitials>
	    <orgname>Collabora</orgname>
	  </info>
	  <para>
	    As far as Salut is concerned, this will be a protocol distinct from
	    local-xmpp.
	  </para>
	</annotation>

	<itemizedlist>
	  <listitem>
	    <para>
	      The link-local service is called 'ytstenut' rather than 'presence',
	      i.e., the PTRs have pattern 'JID._ytstenut._tcp._local.',
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Connection is done by JID and resource as with regular XMPP; the
	      JID part before the '@' symbol is provided explicitly to the
	      connection manager, the server part after '@' is worked out
	      automatically by the connection manager,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The connection manager implements the subscription mechanism
	      described below (<xref linkend="local-ytstenut-subscription"/>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      All implementations must support SASL authentication
	      <citation><xref linkend="rfc2222"/></citation>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <section xml:id="local-ytstenut-subscription">
	<title>Subscription mechanism</title>

	<para>
	  Standard XMPP subscription is implemented exchanging
	  <code>&lt;presence/&gt;</code> stanzas. However, the link-local
	  version of XMPP<citation><xref linkend="xep0174"/></citation> uses
	  m-DNS broadcast to distribute presence information, which makes it
	  unsuitable for exchanging client-specific
	  <code>&lt;presence/&gt;</code> stanzas, so a different mechanism for
	  establishing subscription is needed.
	</para>

	<para>
	  At the same time, it is desirable that the alternative subscription
	  mechanism would be functionally equivalent to standard XMPP
	  subscription so that any user-level APIs could be identical for both
	  the server-based and server-less scenarios. To this end, the
	  local-ytstenut protocol defines a thin layer allowing the relevant
	  <code>&lt;presence/&gt;</code> stanzas to be delivered independently
	  of the m-DNS presence broadcasts.
	</para>

	<para>
	  The local-ytstenut subscription handshake is carried out by exchanging
	  <code>&lt;iq/&gt;</code> <code>set</code> stanzas using
	  <code>urn:ytstenut:local-subscription</code> namespace. These
	  <code>&lt;iq/&gt;</code> stanzas provide a wrapper around appropriate
	  <code>&lt;presence/&gt;</code> stanzas as used by the standard XMPP
	  subscription mechanism, so that a local-ytstenut subscription exchange
	  can be converted into a standard XMPP subscription exchange by simply
	  stripping out the external <code>&lt;iq/&gt;</code> layer.
	</para>

	<para>
	  Compliant local-ytstenut connection managers are required to implement
	  this mechanism.
	</para>

<annotation role='implementation'>
  <info>
    <authorinitials>tf</authorinitials>
    <orgname>Intel</orgname>
  </info>
  <para>
    The initial Telepathy implementation of this protocol might not implement
    this functionality, deferring it to a second iteration; based on the
    experiences with the initial implementation, this, and other, parts of this
    specification might need to be tuned.
  </para>
</annotation>
      </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="messaging">
    <title>Messaging Protocols</title>

    <section xml:id="messaging-app-info">
      <title>Descriptive Application Information</title>

      <para>
	Ytstenut applications need to provide descriptive information about
	themselves that can be presented to the user. At the bare minimum, this
	information includes a suitable, localised, application name.
      </para>
      <para>
	The mechanism for obtaining descriptive application information is XMPP
	Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>; the descriptive information is contained
	in a <code>&lt;identity/&gt;</code> element of <code>category</code>
	'client'. Two new types are defined for use with this category:
	<code>'ytstenut-application'</code> and
	<code>'ytstenut-controller'</code>, corresponding to task-oriented and
	control applications respectively (see <xref
	linkend="intro-application-classes"/>).
      </para>

      <para>
	The <code>name</code> attribute of the <code>&lt;identity/&gt;</code>
	element holds application name, while the <code>xml:lang</code>
	attribute identifies the locale used by the <code>name</code>
	attribute. As per XMPP Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>, the query reply may include multiple
	<code>&lt;identity/&gt;</code> elements of the same category and type,
	but with different <code>xml:lang</code> attribute.
      </para>

      <para>
	If the <code>&lt;query/&gt;</code> of the original request has an
	explicit <code>xml:lang</code> attribute, the reply contents should be
	filtered by that attribute. If the <code>xml:lang</code> attribute of
	the <code>&lt;query/&gt;</code> cannot be matched the respondent may
	return either a suitable fall-back, or all available translations.
      </para>

      <para>
	(For full description of the XML elements, see <xref
	linkend="appendix-schemas"/>).
      </para>

      <example xml:id="messaging-app-info-example">
	<title>Application Information XML example</title>

	<programlisting language="xml"><![CDATA[
<iq to="icecream-maker@custom-foods.com/resource"
    type="get"
    id="appinfo1">

  <query xmlns='http://jabber.org/protocol/disco#info'/
         xml:lang="en-GB"/>

</iq>

 ...

<iq to="a.customer@custom-foods.com/resource"
    type="result"
    id="appinfo1">

  <identity category='client'
            type='ytstenut-application'
            name='Magic Icecream Maker'
	    xml:lang='en-GB'/>

</iq>]]>
	</programlisting>
      </example>

    </section>

    <section xml:id="messaging-app-caps">
      <title>Application Capabilities</title>

      <para>
	Ytstenut applications must advertise their Ytstenut capabilities via XMPP
	Entity Capabilities protocol<citation><xref
	linkend="xep0115"/></citation>, using
	<code>urn:ytstenut:capabilities</code> as the value of the
	<code>node</code> attribute of the <code>&lt;c/&gt;</code> element.
      </para>

      <para>
	Each individual Ytstenut capability is represented by the
	<code>&lt;feature/&gt;</code> element; the <code>var</code> attribute is
	constructed by concatenating an <code>'urn:ytstenut:capabilies:'</code>
	prefix and the canonical name of the capability (for standard
	capabilities defined in <xref linkend="messaging-metadata-caps"/>).
      </para>

      <para>
	In addition, Ytstenut applications should also advertise any data
	transfer protocols they support as above, using the <code>urn</code>s
	defined in <xref linkend="messaging-data-transfer-urns"/> as the value
	of the <code>var</code> attribute. For example, an application
	supporting video playback capability and able to stream files via Jingle
	RTP would be represented as:
      </para>

      <programlisting><![CDATA[
<c node='urn:ytstenut:capabilities'>
  <feature var='urn:ytstenut:capabilities:yts-caps-video' />
  <feature var='urn:ytstenut:data:jingle:rtp' />
<c/>
]]></programlisting>
    </section>

    <section xml:id="messaging-status">
      <title>Extended Status</title>

      <para>
	Extended status information is advertised using XMPP Personal Eventing
	Protocol<citation><xref linkend="xep0163"/></citation>. The status
	payload is held by an <code>&lt;ytstenut:status/&gt;</code> element and
	its attributes; applications with multiple capabilities must include
	an <code>&lt;ytstenut:status/&gt;</code> element for each capability.
      </para>

      <para>
	The following attributes, in addition to those defined in <xref
	linkend="messaging-metadata-attributes"/>, are used with the
	<code>&lt;ytstenut:status/&gt;</code> element:

	<variablelist>
	  <varlistentry>
	    <term><code>version</code></term>

	    <listitem>
	      <para>
		Ytstenut protocol version; required,
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>capability</code></term>

	    <listitem>
	      <para>
		The capability this status applies to; required. The value
		should be preferably one of those defined in <xref
		linkend="messaging-metadata-caps"/>,
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>activity</code></term>

	    <listitem>
	      <para>
		The activity this status represents; optional (if not present
		<code>yts-activity-idle</code> is implied). The value should be
		preferably one of those defined in <xref
		linkend="messaging-metadata-activity"/>
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>primary-capability</code></term>

	    <listitem>
	      <para>
		Boolean indicating whether capability this status applies to is
		the primary capability of the application; optional (if absent
		<code>false</code> is implied).
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>
      </para>

      <para>
	While the <code>&lt;ytstenut:status/&gt;</code> element can be extended
	with custom attributes, no frequently changing information
	(such as current playback position) is permitted as part of status to
	avoid flooding of the network.
      </para>

      <para>
	Human readable description is provided using one or more
	<code>&lt;ytstenut:description/&gt;</code> elements inside the
	<code>&lt;ytstenut:status/&gt;</code> element; each
	<code>&lt;ytstenut:description/&gt;</code> element must have an
	<code>xml:lang</code> attribute, and multiple
	<code>&lt;ytstenut:description/&gt;</code> elements must have a different
	<code>xml:lang</code> attribute each.
      </para>

	<example xml:id="messaging-status-example">
	  <title>Status XML example</title>

	  <programlisting><![CDATA[
<ytstenut:status version='1.0'
                capability='yts-caps-video'
                activity='yts-activity-play'
                uri='some random youtube url'
                volume='0.75'>
  <ytstenut:description xml:lang='en-GB'>
    Playing a video about colour-based optical illusions.
  </ytstenut:description>
</ytstenut:status>]]>
	  </programlisting>
	</example>

      <section xml:id="messaging-status-avatars">
	<title>Support for Avatars</title>

	<para>
	  In addition to the extended status mechanism described above, it is
	  recommended that all Ytstenut implementations support the XMPP User
	  Avatar specification<citation><xref linkend="xep0084"/></citation>.
	</para>
      </section>
    </section>

    <section xml:id="messaging-commands">
      <title>Instruction Messages</title>

      <para>
	Instruction messages are used to send Ytstenut commands and information
	queries; the underlying protocol for exchange of instruction messages
	is defined by the Ad-Hoc Commands XMPP extension<citation><xref
	linkend="xep0030"/></citation>.
      </para>

      <para>
	The Ad-Hoc command extension was defined primarily with a view to
	handling user driven commands and distributed user interfaces. A typical
	Ad-Hoc exchange, therefore, requires two round trips between the
	involved parties: during the first trip UI definition is passed from the
	target entity to the initiating entity, during the second trip the
	command itself is dispatched from the initiating entity to the target
	entity and results are returned.
      </para>

      <para>
	While there will be some Ytstenut use cases where this type of
	(user-driven) exchange is desirable, many Ytstenut exchanges will be
	automated in the background, and using a priory known metadata
	model. This specification, therefore, defines a set of standard commands
	that can be used with the Ad-Hoc mechanism, and stipulates that a well
	defined payload can be included in the initial XML
	<code>&lt;command/&gt;</code> element of the Ad-Hoc exchange; this
	eliminates the need for the the initial round trip.
      </para>

      <para>
	User-driven exchanges, that cannot be encapsulated in terms of standard
	Ytstenut messages, should make use of standard XMPP data
	forms<citation><xref linkend="xep0004"/></citation>. Custom payload
	formats are permitted, where this makes sense for specialised
	applications.
      </para>

	<section xml:id="messaging-commands-message">
	  <title>Message payload: <code>&lt;ytstenut:message/&gt;</code></title>

	  <para>
	    The <code>&lt;ytstenut:message/&gt;</code> element is used to
	    encapsulate the payload of standardised Ytstenut messages.
	  </para>

	  <para>
	    Required attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>version</code>
		</term>
		<listitem>
		  <para>
		    The Ytstenut protocol version,
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Depending on the message purpose, additional attributes are used to
	    define the message payload.
	  </para>
	</section>

	<section xml:id="messaging-commands-nodes">
	  <title>Standardised Ad-Hoc nodes</title>

	<section xml:id="messaging-commands-command">
	  <title><code>ytstenut/command</code></title>

	  <para>
	    A command sent from application <code>A</code> to application
	    <code>B</code> to executed directly by application <code>B</code>.
	  </para>
	  <para>
	    Required <code>&lt;ytstenut:message/&gt;</code> attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>capability</code>
		</term>
		<listitem>
		  <para>
		    Capability on which the command is to operate, preferably
		    using one of the values defined in <xref
		    linkend="messaging-metadata-caps"/>,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>activity</code>
		</term>
		<listitem>
		  <para>
		    Activity to carry out, preferably using one of the values
		    defined in <xref linkend="messaging-metadata-activity"/>,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>time</code>
		</term>
		<listitem>
		  <para>
		    Time of command dispatch with at least millisecond
		    precision, in standard XMPP format<citation><xref
		    linkend="xep0082"/></citation>.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Additional attributes, preferably using those defined in <xref
	    linkend="messaging-metadata-attributes"/>, are used to further
	    qualify the capability and activity specified.
	  </para>

    <example xml:id="messaging-commands-example"> <title>Command example</title>

      <para>
	The following XML snippet tells some other application to start
	playing given video starting 3/4 into the video duration:
      </para>

      <programlisting><![CDATA[

<iq type='set'
    id='command1'
    to='myself@blackbox.local/magic-video-player'
    >
  <command xmlns='http://jabber.org/protocol/commands'
           node='ytstenut/command'
           action='execute'
           xmlns='urn:ytstenut:messages'>

    <ytstenut:message version='1.0'
                      time='1970-01-01T00:00:00.000Z'
                      capability='yts-caps-video'
                      activity='yts-activity-play'
                      uri='some random youtube url'
                      progress='0.75'>
        [Optional command data; binary data base64 encoded]
    </ytstenut:message>
</iq>

 ...

<iq type='result'
    id='command1'
    to='myself@bluebox.local/the-other-player'
    from='myself@blackbox.local/magic-video-player'
    xmlns='urn:ytstenut:messages'/>]]>
      </programlisting>
    </example>

	  <section xml:id="messaging-commands-command-error">
	    <title>Error handling</title>
	    <para>
	      When the resource to which the Ytstenut command pertains is
	      unavailable, the command recipient should return an error that
	      best describes reason why:

	      <variablelist>
		<varlistentry>
		  <term><code>&lt;forbidden/&gt;</code></term>
		  <listitem>
		    <para>
		      The recipient does not have sufficient privileges to
		      carry out the command.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><code>&lt;item-not-found/&gt;</code></term>
		  <listitem>
		    <para>
		      The resource could not be located.
		    </para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </para>
	    <para>
	      The <code>type</code> attribute of the
	      <code>&lt;error/&gt;</code> stanza should be set appropriately:
	      the <code>modify</code> value should be used if the recipient is
	      able to explore other sources for the same resource; the value
	      <code>cancel</code> is used to indicate that no further attempts
	      to execute this command should be made.
	    </para>

	    <para>
	      When handling errors of type <code>modify</code>, the sender must
	      explore each possible source no more than once. When all known
	      sources are exhausted, the initiating application should notify
	      user that the command could not be executed.
	    </para>
	  </section>
	</section>

	<section xml:id="messaging-commands-transfer">
	  <title><code>ytstenut/transfer</code></title>

	  <para>
	    A request by application <code>A</code> to application
	    <code>B</code> to transfer <code>B</code>'s activity to application
	    <code>C</code>.
	  </para>

	  <para>
	    Required <code>&lt;ytstenut:message/&gt;</code> attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>capability</code>
		</term>
		<listitem>
		  <para>
		    Capability that is subject of the transfer,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>jid</code>
		</term>
		<listitem>
		  <para>
		    JID of the application to transfer to.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Additional attributes, preferably using those defined in <xref
	    linkend="messaging-metadata-attributes"/>, may be used to further
	    qualify the capability specified.
	  </para>

	</section>

	<section xml:id="messaging-commands-find">
	  <title><code>ytstenut/find</code></title>

	  <para>
	    A request by an application <code>A</code> to a control application
	    <code>C</code> to identify a suitable application <code>B</code> to
	    dispatch a (subsequent) command to:

	    <itemizedlist>
	      <listitem>
		<para>
		  The criteria for the search is given by the supplied
		  attributes (e.g., application capability would be specified
		  using the <code>capability</code> attribute),
		</para>
	      </listitem>

	      <listitem>
		<para>
		  The search is limited to the service context the control
		  application is part of, or, in the case of the home cloud, the
		  device the control application is running on,
		</para>
	      </listitem>
	      <listitem>
		<para>
		  The control application returns the result of the search using
		  the <code>jid</code> attribute of the
		  <code>&lt;ytstenut:message/&gt;</code> payload.
		</para>
	      </listitem>
	    </itemizedlist>
	  </para>

<annotation role='comment'>
  <info>
    <authorinitials>tf</authorinitials>
    <orgname>Intel</orgname>
  </info>
  <para>
    Rationale: because of the need to
    facilitate e2e encryption, commands cannot be proxied through
    control applications; the <code>find</code> request allows
    clients to initiate a transfer to an application that might
    not yet be running on the target device.
  </para>

  <para>
    Not allowing proxying of commands via intermediate applications also
    significantly simplifies issues related to access control.
  </para>
</annotation>

	  <section xml:id="messaging-commands-find-error">
	    <title>Error handling</title>

	    <para>
	      If no suitable running application matching the specified criteria
	      can be identified but a suitable application is available on the
	      system, the control application must return immediately with
	      status <code>executing</code>, then attempt to start such suitable
	      application.
	    </para>

	    <para>
	      If a suitable application does not exist on the system, the
	      control application must return immediately an error condition
	      <code>&lt;item-not-found/&gt;</code>.
	    </para>

	    <para>
	      When the spawned client application successfully starts up, the
	      control application returns the result of the search using the
	      <code>jid</code> attribute of the
	      <code>&lt;ytstenut:message/&gt;</code> payload. If the application
	      fails to start, the control application must dispatch response
	      with status <code>completed</code> and an error; the error
	      condition should indicate why the application failed to start, if
	      that is known.
	    </para>
	  </section>
	</section>
      </section>
    </section>

    <section xml:id="messaging-metadata">
      <title>Common metadata classes</title>

      <para>
	The canonical definition is given in <xref linkend="appendix-schemas"/>;
	the following information is extracted from the XML schemas for
	convenience.
      </para>


      <section xml:id="messaging-metadata-caps">
	<title>Common capability classes</title>

	<para>
	  <variablelist>
	    <varlistentry>
	      <term>
		<code>yts-caps-control</code>
	      </term>

	      <listitem>
		<para>
		  control application,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-caps-audio</code>
	      </term>

	      <listitem>
		<para>
		  audio playback capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-caps-video</code>
	      </term>

	      <listitem>
		<para>
		  video playback capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-caps-image</code>
	      </term>

	      <listitem>
		<para>
		  image display capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-caps-html</code>
	      </term>

	      <listitem>
		<para>
		  html rendering capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-caps-antivirus</code>
	      </term>

	      <listitem>
		<para>
		  anti-virus capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	  </variablelist>
	</para>

	<annotation role='comment'>
	    <info>
	      <authorinitials>tf</authorinitials>
	      <orgname>Intel</orgname>
	    </info>
	    <para>
	      More standard definitions should be added here; open to
	      suggestions.
	    </para>
	  </annotation>

	<para>
	  Custom capabilities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom capabilities must not use
	  'yts-' prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-activity">
	<title>Common activity classes</title>

	<para>
	  Absence of the 'activity' attribute, or its empty value, imply idle
	  state.

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>yts-activity-playback</code>
	      </term>

	      <listitem>
		<para>
		  playback,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-activity-pause</code>
	      </term>
	      <listitem>
		<para>
		  paused state,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-activity-ffw</code>
	      </term>
	      <listitem>
		<para>
		  fast forward,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-activity-rwd</code>
	      </term>
	      <listitem>
		<para>
		  rewind,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-activity-scan</code>
	      </term>
	      <listitem>
		<para>
		  scan,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>yts-activity-volume</code>
	      </term>
	      <listitem>
		<para>
		  volume adjustment.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<annotation role='comment'>
	  <info>
	    <authorinitials>tf</authorinitials>
	    <orgname>Intel</orgname>
	  </info>
	  <para>
	  More standard definitions should be added here, open to suggestions.
	  </para>
	</annotation>

	<para>
	  Custom activities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom activities must not use 'yts-'
	  prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-attributes">
	<title>Common attributes</title>

	<para>
	  <variablelist>
	    <varlistentry>
	      <term><code>protocol</code></term>

	      <listitem>
		<para>
		  <code>urn</code> identifying a suitable protocol through which
		  the resource on which to operate can be obtained (see <xref
		  linkend="messaging-data-transfer-urns"/>). Multiple protocols
		  can be listed as a space separated list, in descending order
		  of preference.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>uri</code></term>

	      <listitem>
		<para>
		  <code>uri</code> a of a resource associated with activity.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>uid</code></term>

	      <listitem>
		<para>
		  Universal id identifying resource associated with activity,

		<annotation role='comment'>
		  <info>
		    <authorinitials>tf</authorinitials>
		    <orgname>Intel</orgname>
		  </info>
		  <para>
		    The idea is being able to use something like, for example,
		    musicbrainz id to identify the resource, though in practice
		    this might be hard to extend beyond audio
		  </para>
		</annotation>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>volume</code></term>

	      <listitem>
		<para>
		  volume level (floating point number from &lt;0,1&gt;),
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>progress</code></term>

	    <listitem>
	      <para>
		activity progress (floating point number from
		&lt;0,1&gt; this is the preferred way of passing information
		such as stream position,
	      </para>
	    </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>position</code></term>

	      <listitem>
		<para>
		  activity position (floating point number); NB: applications
		  should use the <code>progress</code> attribute whenever
		  possible instead of 'position',
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>description</code></term>

	      <listitem>
		<para>
		  description: human readable description, suitable for
		  presentation to user,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jid</code></term>

	      <listitem>
		<para>
		  XMPP id,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>speed</code></term>

	      <listitem>
		<para>
		  speed of activity (floating point number; 1.0 indicates
		  normal speed).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<para>
	  Custom attributes can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom attributes must not use 'yts-'
	  prefix.
	</para>
      </section>

    </section>
    <section xml:id="messaging-data-transfer">
      <title>Data Transfer Protocols</title>

      <para>
	This section defines standard data transfer protocols to be used by
	Ytstenut clients; this list does not restrict clients to these protocols
	alone, but sets out preferred protocols.
      </para>

      <section xml:id="messaging-data-transfer-files">
	<title>File Transfers</title>

	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		The preferred file transfer protocol is SI File
		Transfer<citation><xref linkend="xep0096"/></citation>; this
		protocol must be supported by all compliant Ytstenut clients for
		which a <code>file</code> constitutes a meaningful data unit,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		It is recommended that clients also implement Jingle
		File Transfer<citation><xref linkend="xep0234"/></citation>;
		this protocol is currently in experimental stage, but once it is
		reaches the draft stage, it will be adopted as the default file
		transfer protocol for Ytstenut clients.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </section>

      <section xml:id="messaging-data-transfer-streaming">
	<title>Streaming</title>

	<para>
	  The preferred streaming protocol is XMPP Jingle RTP<citation><xref
	  linkend="xep0167"/></citation>; applications that support media
	  streaming should implement this protocol.
	</para>
      </section>

      <section xml:id="messaging-data-transfer-urns">
	<title>URNs for common resource fetching protocols</title>

	<para>
	  This section codifies <code>urn</code>s to be used with the
	  <code>uri</code> attribute of Ytstenut commands to indicate how to
	  reach the resource, and when advertising application capabilities (see
	  <xref linkend="messaging-app-caps"/>). Each <code>urn</code> is formed
	  by combining a '<code>urn:ytstenut:data:</code>' prefix with one of the
	  protocol ids defined below:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><code>si-file</code></term>

	      <listitem>
		<para>
		  Resource can be obtained from initiating application using SI
		  File Transfer<citation><xref linkend="xep0096"/></citation>,
		  see <xref linkend="messaging-data-transfer-files"/>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jingle:ft</code></term>

	      <listitem>
		<para>
		  Resource can be obtained from initiating application using
		  XMPP Jingle File Transfer<citation><xref
		  linkend="xep0234"/></citation>, see <xref
		  linkend="messaging-data-transfer-files"/>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jingle:rtp</code></term>

	      <listitem>
		<para>
		  Resource can be obtained from initiating application using
		  XMPP Jingle RTP<citation><xref linkend="xep0167"/></citation>,
		  see <xref linkend="messaging-data-transfer-streaming"/>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>upnp-av</code></term>

	      <listitem>
		<para>
		  Resource can be obtained using UPnP AV protocols.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <appendix xml:id="appendix-schemas">
    <title>Ytstenut XML Schemas</title>

    <section xml:id="appendix-schemas-ytstenut-subscription">
      <title>Schema for <code>urn:ytstenut:local-subscription</code></title>
      <programlisting><!-- The xi:include line must be aligned directly at the
			   end of this comment, as any padding will end up in
			   the final document !!!
		      --><xi:include
	     parse="text"
	     href="./ytstenut-protocol-subscription.xsd" /></programlisting>
    </section>

    <section xml:id="appendix-schemas-ytstenut-status">
      <title>Schema for <code>urn:ytstenut:status</code></title>
      <programlisting><!-- The xi:include line must be aligned directly at the
			   end of this comment, as any padding will end up in
			   the final document !!!
		      --><xi:include
	     parse="text"
	     href="./ytstenut-protocol-status.xsd" /></programlisting>
    </section>

    <section xml:id="appendix-schemas-ytstenut-messages">
      <title>Schema for <code>urn:ytstenut:messages</code></title>
      <programlisting><!-- The xi:include line must be aligned directly at the
			   end of this comment, as any padding will end up in
			   the final document !!!
		      --><xi:include
	     parse="text"
	     href="./ytstenut-protocol-messages.xsd" /></programlisting>
    </section>
  </appendix>

  <?hard-pagebreak?>
  <bibliography>
    <title>External Resources</title>
    <bibliodiv>
    <title></title>

    <biblioentry xml:id="rfc3920">
      <title>RFC 3920</title>
      <subtitle>Extensible Messaging and Presence Protocol (XMPP):
      Core</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://tools.ietf.org/html/rfc3920"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="rfc3921">
      <title>RFC 3921</title>
      <subtitle>Extensible Messaging and Presence Protocol (XMPP): Instant
      Messaging and Presence</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://tools.ietf.org/html/rfc3921"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="rfc2222">
      <title>RFC 2222</title>
      <subtitle>Simple Authentication and Security Layer (SASL)</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource>
	<link xlink:href="http://tools.ietf.org/html/rfc2222"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="rfc3923">
      <title>RFC 3923</title>
      <subtitle>End-to-End Signing and Object Encryption for the Extensible
      Messaging and Presence Protocol (XMPP)</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://tools.ietf.org/html/rfc3923"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0004">
      <title>XEP-0030</title>
      <subtitle>Data Forms</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0004.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0030">
      <title>XEP-0030</title>
      <subtitle>Service Discovery</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0030.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0050">
      <title>XEP-0050</title>
      <subtitle>Ad-Hoc Commands</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0050.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0060">
      <title>XEP-0060</title>
      <subtitle>Publish-Subscribe</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0060.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0082">
      <title>XEP-0082</title>
      <publishername>XMPP Standards Foundation</publishername>
      <subtitle>XMPP Date and Time Profiles</subtitle>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0082.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0084">
      <title>XEP-0084</title>
      <subtitle>User Avatar</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0084.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0096">
      <title>XEP-0096</title>
      <subtitle>SI File Transfer</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0096.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0115">
      <title>XEP-0115</title>
      <subtitle>Entity Capabilities</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0115.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0163">
      <title>XEP-0163</title>
      <subtitle>Personal Eventing Protocol</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0163.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0166">
      <title>XEP-0166</title>
      <subtitle>Jingle</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0166.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0167">
      <title>XEP-0167</title>
      <subtitle>Jingle RTP Sessions</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0167.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0174">
      <title>XEP-0174</title>
      <subtitle>Serverless Messaging</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0174.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0234">
<!--
      <author>
	<personname>
	  <firstname>Peter</firstname>
	  <surname>Saint-Andre</surname>
	</personname>
      </author>
-->
      <title>XEP-0234</title>
      <subtitle>Jingle File Transfer</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0234.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="jng-xtls">
      <title>Jingle XTLS</title>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/inbox/jingle-xtls.html"/>
      </bibliosource>
    </biblioentry>

    </bibliodiv>
  </bibliography>
</article>
