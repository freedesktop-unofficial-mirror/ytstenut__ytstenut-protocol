<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:xlink="http://www.w3.org/1999/xlink"
	 xml:id="nscreen-protocol" xml:lang="en" class="specification">
  <info>

    <title>nScreen Protocol Specification</title>
	<subtitle>Version 1.0</subtitle>

	<orgname>Intel Corporation</orgname>

    <author>
      <personname>
	<firstname>Tomas</firstname> <surname>Frydrych</surname>
<!--
      <affiliation>
        <orgname>Intel Corporation</orgname>
      </affiliation>
-->
      </personname>
      <email>tf@linux.intel.com</email>
    </author>

    <revhistory>
      <revision>
         <revnumber>0.1</revnumber>
         <date>22 October 2010</date>
         <revremark>Initial draft</revremark>
      </revision>
      <revision>
         <revnumber>0.2</revnumber>
         <date>22 October 2010</date>
         <revremark>
	   revised based on preliminary comments from Collabora
	 </revremark>
      </revision>
    </revhistory>
  </info>

<?hard-pagebreak?>

  <section xml:id="intro">
    <title>Introduction</title>
    <para>
      Users often carry out similar activities on different devices, e.g., watch
      videos on a smart phone, laptop, or a TV set. However, as the user moves
      in time and space, the optimal choice of a device for any given activity
      might change: a smart phone might be the optimal video viewing platform
      while travelling on a train, but a TV set might be optimal in the comfort
      of one's living room.
    </para>

    <para>
      The nScreen framework aims to facilitates seamless transition of the
      user's activities as she moves around. It does so by providing a
      communication channels through which individual user-facing applications
      on distinct devices can cooperate and coordinate their discrete
      behaviours, and in so construct a dynamic and homogeneous experience
      spanning the devices involved.
    </para>

    <para>
      The activities for which consumers use computers are impossible to
      enumerate, and are set to evolve. Consequently the nScreen framework does
      not seek to narrowly define the activities and/or services that might fall
      withing its scope, nor it seeks to prescribe the ways in which such
      activities or tasks should be accomplished. Rather the nScreen framework
      is a set of generic protocols that can support new activities and services
      without the need to modify the core protocols.
    </para>

    <para>
      More specifically, the aims of the nScreen framework are as follows:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  To provide unified discovery, connection and transport mechanism that
	  could be utilised on a variety of hardware and software platforms by a
	  wide spectrum of user-facing applications,
	</para>
      </listitem>
      <listitem>
	<para>
	  To provide means for transmitting meta-data describing user-oriented
	  activities, and doing so in secure manner protecting user privacy,
	</para>
      </listitem>
      <listitem>
	<para>
	  To provide standard meta-data definitions for most common user-facing
	  activities, so as to allow common classes of applications to
	  inter-operate without having to know anything about the implementation
	  details of their nScreen partners.
	</para>
      </listitem>
    </itemizedlist>

    <section xml:id="intro-usecases">
      <title>Basic Use cases</title>

      <para>
	nScreen use cases fall into two broad categories:
      </para>

      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Subscription-based services: these are provided by discrete
	      entities, each operating their own nScreen server. nScreen users
	      connect to this server using credentials agreed with the service
	      provider, and interact with applications provided by the service
	      provider through their server.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Applications interacting within a home cloud: the home cloud use
	      case differs from the subscription service by the absence of a
	      central server; instead the cloud transparently fulfils the role
	      of a subscription-less server.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The nScreen framework aims to support both of these scenarios in a
	transparent manner.
      </para>

    </section>

    <section xml:id="intro-application-classes">
      <title>Application Classes</title>

      <para>
	nScreen applications can be divided into two broad classes:

	<itemizedlist>
	  <listitem>
	    <para>
	      Task-oriented applications: these are the principal participants
	      in the nScreen mesh. They are user-facing applications, such as
	      media players, that have been enriched by adding the nScreen
	      capabilities.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Control Applications: these provide background nScreen services on
	      an nScreen-enabled devices. their principal purpose is to allow
	      task-oriented applications to direct their communications at a
	      device, rather than a specific task-oriented application on that
	      device, and to ensure that appropriate task-oriented application
	      is available (e.g., by spawning of suitable application on the
	      device in response to incoming requests).
	    </para>

	    <para>
	      While control applications can be purely background processes,
	      when provided with a suitable UI they can be used as generic
	      nScreen remote controls.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </section>

    <section xml:id="intro-document-structure">
      <title>Document Structure</title>

      <para>
	The remainder of this document is divided into three parts: <xref
	linkend="comm-protocols"/>, describes the protocols that define the
	nScreen communication backbone, <xref linkend="local-nscreen"/>,
	specifies link-local nScreen protocol used for server-less nScreen
	communication, and <xref linkend="messaging"/>, describes the nScreen
	messaging protocols and metadata model.
      </para>
    </section>
  </section>

<?hard-pagebreak?>

  <section xml:id="comm-protocols">
    <title>Communication Backbone Protocols</title>

    <section xml:id="comm-protocols-intro">
      <title>Overview</title>

      <para>
	The nScreen communication protocols are built on the existing XMPP (aka
	'jabber') standard. The reasons for choosing XMPP as the basic transport
	protocol are:

	<itemizedlist>
	  <listitem>
	    <para>
	      Using an established standard means that much of the wheel needs
	      not to be reinvented,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is supported on a broad range of hardware and software
	      platforms, thus aiding the speed with which the nScreen framework
	      can be rolled out,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is an open standard that can be used without difficulties
	      over licensing,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is extensible by design,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is capable of operating both in a server-based and
	      server-less manner, and supports both of these modes a in
	      transparent way,
	    </para>
	  </listitem>


	  <listitem>
	    <para>
	      XMPP is XML-based, so that implementation of extensions is
	      simplified by being able to use standard XML-processing tools,
	      such a parsers, etc.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The nScreen framework defines two extensions to XMPP:

	<itemizedlist>
	  <listitem>
	    <para>
	      Protocols for encoding of nScreen meta-data,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A server-less protocol similar to link-local XMPP<citation><xref
	      linkend="xep0174"/></citation> , but reserved for nScreen use.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	In addition, at number of points, the nScreen specification mandates
	the use of standard, but optional, XMPP features, particularly so, where
	this is desirable to improve security and privacy.
      </para>

      <section xml:id="comm-protocols-security">
	<title>Security and Privacy Considerations</title>

	<para>
	  The flexible and extensible nature of the nScreen framework means that
	  it is not possible to predict what kind of data my be transmitted via
	  the protocol in its real-world deployment. Furthermore, the
	  expectation of deployment on variety of platforms, ranging from
	  desktop computers to mobile phones, means that multiple
	  implementations of the protocol will be in use. It is, therefore,
	  paramount that security and privacy of user data is a key factor in
	  the design of the protocol itself. More specifically:

	  <itemizedlist>
	    <listitem>
	      <para>
		The protocol must facilitate privacy of data in transit,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Reliable identity verification mechanism must be available,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		The protocol must provide structured access control to user's
		local resources.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<para>
	  With regards to the above, the following should be noted:

	  <itemizedlist>
	    <listitem>
	      <para>
		XMPP on its on only provides client-to-server privacy, and as
		such is susceptible to server eavesdropping,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Normal XMPP presence information is broadcast across all
		subscribed contacts, which might not be appropriate for certain
		types of data that might be included in nScreen extended status
		message.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </section>
    </section>

    <section xml:id="comm-protocols-sub-and-authentication">
      <title>Authentication, identity verification, subscription</title>

      <section xml:id="comm-protocols-jid">
	<title>nScreen JID</title>

	<para>
	  All nScreen applications, regardless whether running in server-based
	  or server-less context, are identified using a bare XMPP
	  JID<citation><xref linkend="rfc3920"/></citation>. A single
	  application connection to the nScreen mesh is identified by a fully
	  qualified JID, consisting of a bare JID identifying the application
	  and a resource identifier; multiple simultaneous connections by single
	  application are permitted and differentiated by the resource part of
	  the fully qualified JID (an example of a bare JID would be
	  <code>application@somewhere.com</code> while a fully qualified JID
	  would be <code>application@somewhere.com/myresource</code>.
	</para>

	<para>
	  In the remainder of this document, the term 'JID' is used to refer
	  to bare JIDs; if a fully qualified jabber id is meant, this will
	  always be explicitly stated.
	</para>
      </section>

      <section xml:id="comm-protocols-authentication">
	<title>Authentication</title>

	<para>
	  Authentication is accomplished via SASL per core XMPP
	  protocol<citation><xref linkend="rfc3920"/></citation>. SASL
	  authentication must be implemented both for both server-based and
	  server-less contexts.
	</para>
      </section>

      <section xml:id="comm-protocols-identity">
	<title>
	Identity Verification
	</title>

	<section xml:id="comm-protocols-identity-server">
	  <title>Identity Verification in Server-Based Context</title>

	  <para>
	    Standard XMPP does not provide a formal mechanism for identity
	    verification. Because the authentication of two communicating users,
	    A and B, is typically done separately and independently by two
	    different servers, A's trust in B's identity implies A's trust in
	    the authentication procedures of B's service provider, which cannot
	    be automatically granted.  Therefore, this generic scenario is only
	    acceptable if data exchanged between A and B contains no sensitive
	    information, i.e., for what essentially amounts to an anonymous
	    nScreen service.
	  </para>

	  <para>
	    An nScreen service that requires reliable identity verification must
	    either implement additional identity verfication measures beyond
	    what is specified by the current version of the protocol, or be
	    implemented using a dedicated nScreen server that requires direct
	    login, and does not permit server hops (i.e., both A and B are
	    logging into the same server in order to talk to each other). In
	    this situation the service provider is fully in control of the
	    authentication procedure, and, assuming 1:1 mapping between users
	    and their authentication credentials is in place, successful
	    authentication provides also for identity verification.
	</para>
	</section>

	<section xml:id="comm-protocols-identity-cloud">
	  <title>Identity Verification in Server-Less Context</title>

	  <para>
	    In server-less context of a home cloud, the 1:1 mapping between
	    nScreen users and authentication credentials cannot be guaranteed; a
	    simple home cloud set up might rely on a shared secret to allow
	    applications across the cloud to authenticate, which in turn allows
	    an authenticated application to spoof another application.
	  </para>

	  <para>
	    Although identity spoofing carries with it lesser risks in the
	    context of the home cloud, the following messures are required to be
	    taken by compliant nScreen implementations to improve security:

	    <itemizedlist>
	      <listitem>
		<para>
		  Applications must not make assumptions about identity of other
		  nScreen participants in the cloud context, unless they
		  implement additional identity verification procedures not
		  specifiend by the current version of the nScreen protocol,
		</para>
	      </listitem>

	      <listitem>
		<para>
		  Applications running both in server-based and server-less
		  contexts must not inject data from server-based streams into
		  the cloud.
		</para>
	      </listitem>
	    </itemizedlist>
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-future">
	  <title>Future Expectations</title>

	  <para>
	    Additional identity verification mechanism addressing the current
	    limitations, using more robust mechanisms (such as PKI) will be
	    defined in future versions of the protocol.
	  </para>
	</section>
      </section>

      <section xml:id="comm-protocols-subscription">
	<title>Subscription</title>

	<para>
	  The nScreen framework uses a subscription mechanism to provide access
	  control between nScreen applications; the details of the subscription
	  mechanism vary between the server-based and server-less modes of
	  operation.
	</para>

	<section xml:id="comm-protocols-server-subscription">
	  <title>Server-end subscription</title>

	  <para>
	    Server-based nScreen services must implement standard subscription
	    mechanism as set out by the core XMPP protocol<citation><xref
	    linkend="rfc3920"/></citation> and must comply with the subscription
	    policies the core specification sets out.
	  </para>

	  <para>
	    Available outward facing services to which users can subscribe
	    should be advertised by the server via XMPP Service Discovery
	    mechanism <citation><xref linkend="xep0030"/></citation>.
	  </para>
	</section>

	<section xml:id="comm-protocols-local-subscription">
	  <title>Subscription in server-less context</title>

	  <para>
	    The standard, server-centric, XMPP subscription mechanism is not
	    applicable for the link-local set up; in order to circumvent this
	    limitation, the local-nscreen protocol specification defined later
	    in this document (see <xref linkend="local-nscreen"/>), defines a
	    separate subscription mechanism to use in its place.
	  </para>
	</section>

      </section>
    </section>

    <section xml:id="comm-protocols-privacy">
      <title>Privacy Protocols</title>

      <para>
	The nScreen protocol specifies two sets of features aiming to ensure
	privacy of user data: the use of TLS and the use of end-to-end
	encryption. TLS layer facilitates private client-to-server and
	server-to-server data exchange. It does not, however, prevent
	eavesdropping by a server involved in data transmission. As such, TLS
	provides sufficient protection only for low risk data. Services wishing
	to transmit high risk data (e.g., banking details and such) must
	either secure the server (i.e., ensure no server hops are involved and
	no sensitive data is leaked in the presence information), or,
	preferably make use of end-to-end encryption in addition to TLS.
      </para>

      <section xml:id="comm-protocols-privacy-tls">
	<title>TLS</title>

	<para>
	  Compliant nScreen applications, both servers and clients, must
	  support TLS as specified by the core XMPP protocol <citation><xref
	  linkend="rfc3920"/></citation>, and must use TLS secured
	  connections exclusively, both for client-to-server and
	  server-to-server connections; both compliant servers and clients are
	  required to refuse connections that do not use TLS.
	</para>
      </section>

      <section xml:id="comm-protocols-privacy-e2e">
	<title>End to end encryption</title>

	<para>
	  The end-to-end encryption to be used by nScreen clients is described
	  by the XMPP e2e extension <citation><xref
	  linkend="rfc3923"/></citation>.

	  <annotation role="comment">
	    <info>
	      <authorinitials>tf</authorinitials>
	    </info>
	    <para>
	      Ideally, some form of e2e TLS channel for exchange of presence
	      and messages would be preferable, but the xep-e2e will do in
	      principle; we are unlikely to be implementing this initially
	      anyway.
	    </para>
	  </annotation>

	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="local-nscreen">
      <title>Local-nscreen protocol</title>

      <para>
	The local-nscreen protocol allows for automatic connection between
	nScreen clients running on the same LAN. It is derived from the
	local-xmpp protocol, but with some important changes:

	<annotation role="comment">
	  <info>
	    <authorinitials>tf</authorinitials>
	  </info>
	  <para>
	    I think it should be possible to implement these difference as an
	    --nscreen command line option to salut, really.
	  </para>
	</annotation>

	<itemizedlist>
	  <listitem>
	    <para>
	      The link-local service is called 'nscreen' rather than 'presence',
	      i.e., the PTRs have pattern 'JID._nscreen._tcp._local.',
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Connection is done by JID and resource as with regular XMPP; the
	      JID part before the '@' symbol is provided explicitely to the
	      connection manager, the server part after '@' is worked out
	      automatically by the connection manager.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The connection manager implements a subscription
	      mechanism described below (<xref linkend="local-nscreen-subscription"/>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      All implementations must support SASL authentication.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <section xml:id="local-nscreen-subscription">
	<title>Subscription mechanism</title>

	<para>
	  Standard XMPP subscription is implemented exchanging
	  <code>&lt;presence&gt;</code> stanzas. However, the link-local version
	  of XMPP<citation><xref linkend="xep0174"/></citation> uses mdns
	  broadcast to distribute presence information, which makes it
	  unsuitable for exchanging client-specific
	  <code>&lt;presence&gt;</code> stanzas, so a different mechanism for
	  establishing subscription is needed.
	</para>

	<para>
	  At the same time, it is desirable that the alternative subscription
	  mechanism would be functionally equivalent to standard XMPP
	  subscription so that any user-level APIs could be identical for both
	  the server-based and server-less scenarios. To this end, the
	  local-nscreen protocol defines a thin layer allowing the relevant
	  <code>&lt;presence&gt;</code> stanzas to be delivered independently of
	  the mdns presence broadcasts.
	</para>

	<para>
	  The local-nscreen subscription hanshake is carried out by exchanging
	  <code>&lt;iq&gt;</code> <code>set</code> and
	  <code>result</code>stanzas using
	  <code>nscreen::local-subscription</code> namespace. These
	  <code>&lt;iq&gt;</code> stanzas provide a wrapper around appropriate
	  <code>&lt;presence&gt;</code> stanzas as used by the standard XMPP
	  subscription mechanims, so that a local-nscreen subscription exchange
	  can be converted into a standard XMPP subscription exchange by simply
	  stripping out the external <code>&lt;iq&gt;</code> layer.
	</para>

	<para>
	  Complient local-nscreen connection managers are required to implement
	  this mechanism.
	</para>

<annotation role='comment'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    The initial Telepathy implementation of this protocol might not implement
    this functionality, deferring it to a second iteration; based on the
    experiences with the initial implementation, this, and other, parts of this
    specification might need to be tuned.
  </para>
</annotation>
      </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="messaging">
    <title>Messaging Protocols</title>

    <annotation role="comment">
      <info>
	<authorinitials>tf</authorinitials>
      </info>
      <para>
	This is the upper layer of the nScreen protocols; this is the one bit we
	have a fairly good idea what we want to do -- we already have a working
	proof-of-concept implementation of libnscreen on the top of telepathy
	working along these lines; except we do not use XML for the messages but
	use specially crafted strings inside normal presence and IM messages.
      </para>
    </annotation>

    <para>
      The purpose of the nScreen protocols is to allow applications to exchange
      meta-data that would allow them to coordinate their activity across
      multiple devices; the protocol does not aim to provide mechanisms for
      actual data transfers, though in some common and specific cases it
      mandates which other standard protocols should be used, see <xref
      linkend="messaging-data-transfer"/>.
    </para>

    <para>
      The messaging consists of three basic building blocks: application
      description information, extended status information, and instruction
      messages. Message of one the latter two types is conceptually a data tuple
      describing an activity in terms of a subject (capability in use), verb
      (the activity itself) and set of attributes (what and how). The primary
      difference between the two types of messages is in the tense: status
      message describe a present state, while instruction messages refer to a
      desired future state.
    </para>

    <para>
      In order to facilitate communication between common application classes,
      the protocol defines the subjects, verbs and attributes for common user
      activities. At the same time, new subjects, verbs and attributes can be
      defined and used by specialised applications.
    </para>

    <para>
      (For full XML definition see <xref linkend="appendix-dtd"/>.)
    </para>

    <section xml:id="messaging-app-info">
      <title>Descriptive Application Information</title>

      <para>
	nScreen applications need to provide descriptive information about
	themselves that can be presented to the user. At the bare minimum, this
	information includes a suitable, localised, application name.
      </para>
<annotation role='comment'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    Hm, how will this work in server-less context, are the XEP-0030 iqs forwared
    to the application to reply to ?
  </para>
</annotation>
      <para>
	The mechanism for obtaining descriptive application information is XMPP
	Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>; the descriptive information is contained
	in a <code>&lt;identity&gt;</code> element of <code>category</code>
	'client'. Two new types are defined for use with this category:
	<code>'nscreen-application'</code> and
	<code>'nscreen-controller'</code>, corresponding to task-oriented and
	control applications respectively (see <xref
	linkend="intro-application-classes"/>).
      </para>

      <para>
	The <code>name</code> attribute of the <code>&lt;identity&gt;</code>
	element holds application name, while the <code>xml:lang</code>
	attribute identifies the locale used by the <code>name</code>
	attribute. As per XMPP Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>, the query reply may include multiple
	<code>&lt;identity&gt;</code> elements of the same category and type,
	but with different <code>xml:lang</code> attribute. However, if the
	<code>&lt;query&gt;</code> of the original request has an explicit
	<code>xml:lang</code> attribute, the reply contents should be filtered
	by that attribute. If the <code>xml:lang</code> attribute of the
	<code>&lt;query&gt;</code> cannot be matched the repsondent may return
	either a suitable fallback, or all available translations.
      </para>

      <para>
	(For full description of the XML elements, see <xref
	linkend="appendix-dtd"/>).
      </para>

      <section xml:id="messaging-app-info-example">
	<title>Application Information XML example</title>

	<programlisting language="xml">
	  <![CDATA[
<iq to="icecream-maker@custom-foods.com/resource"
    type="get"
    id="appinfo1">

  <query xmlns='http://jabber.org/protocol/disco#info'/
         xml:lang="en-GB"/>

</iq>

 ...

<iq to="a.customer@custom-foods.com/resource"
    type="result"
    id="appinfo1">

  <identity category='client'
            type='nscreen-application'
            name='Magic Icecream Maker'
	    xml:lang='en-GB'/>

</iq>]]>
	</programlisting>
      </section>

    </section>

    <section xml:id="messaging-app-caps">
      <title>Application Capabilities</title>

      <para>
	nScreen applications advertise their capabilites using XMPP Entity
	Capabilites protocol<citation><xref linkend="xep0115"/></citation>,

<annotation role='todo'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    Flesh this out with the uri scheme that allows arbitrary nscreen caps to
    be defined on the fly.
  </para>
</annotation>
      </para>
    </section>

    <section xml:id="messaging-status">
      <title>Extended Status</title>

      <para>
	Extended status information is advertised using XMPP Personal Eventing
	Protocol<citation><xref linkend="xep0163"/></citation>.  The status
	payload is help by an <code>&lt;nscreen:status&gt;</code> element,
	holding an unspecified number of <code>&lt;nscreen:capability&gt;</code>
	elements that describe status for each capability the client supports.
      </para>

      <para>
	The <code>&lt;nscreen:capability&gt;</code> element can be extended with
	custom attributes; however, no frequently changing information (such as
	current playback position) is permitted as part of status to avoid
	flooding of the network.
      </para>

      <para>
	In addition to the extended status mechanism described above, it is
	recommended that all nScreen implementations support the XMPP User
	Avatar specification<citation><xref linkend="xep0084"/></citation>.
      </para>

      <section xml:id="messaging-status-example">
	<title>Status XML example</title>

	<programlisting><![CDATA[
<nscreen:status version='1.0'
                primary-capability='ns-caps-video'>

  <nscreen:capability type='ns-caps-video'
                      activity='ns-activity-play'
                      uri='some random youtube url'
                      volume='0.75'>

    [Description]

  </nscreen:capability>
</nscreen:status>]]>
	</programlisting>
      </section>
    </section>

    <section xml:id="messaging-commands">
      <title>Instruction Messages</title>

      <para>
	Instruction messages are used to send nScreen commands and information
	queries. The protocol defines a set of generic xml elements that are
	used to encapsulate nScreen messages, with parameters transmitted via
	xml attributes.
      </para>

      <para>
	The messages per se are exchanged using XMPP <code>&lt;iq&gt;</code>
	stanzas, with xmlns of 'nscreen::message'. Commands are dispatched using
	<code>&lt;iq&gt;</code> stanza of type <code>set</code>, while
	information requests are sent using type <code>get</code>. All
	<code>get</code> / <code>set</code> requests are acknowledged by the
	recepient using <code>&lt;iq&gt;</code> stanzas of type
	<code>result</code> or <code>error</code>.
      </para>

      <section xml:id="messaging-commands-iq-set">
	<title>Commands</title>

	<para>
	  Commands use <code>set</code> type stanzas; the command payload is
	  carried by one of the following xml elements:

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>&lt;nscreen:command&gt;</code>
	      </term>
	      <listitem>
		<para>
		  A command sent from app A to app B to executed directly by app
		  B. <code>&lt;nscreen:command&gt;</code> elements have a
		  required <code>time</code> attribute (see <xref
		  linkend="messaging-commands-attributes"/>).
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>&lt;nscreen:transfer&gt;</code>
	      </term>
	    <listitem>
	      <para>
		A request by application A to application B to transfer B's
		activity to application C; the identity of C is specified by a
		required <code>jid</code> attribute.
	      </para>
	    </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </section>

      <section xml:id="messaging-commands-iq-get">
	<title>Information requests</title>

	<para>
	  Information requests use <code>get</code> type stanzas; the command
	  payload is carried by one of the following xml elements:

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>&lt;nscreen:find&gt;</code>
	      </term>
	      <listitem>
		<para>
		  A request by app A to a control app C to identify suitable app
		  B to dispatch a command to. The criteria for the search is
		  given by the supplied attributes, e.g., application capability
		  would be specified using the <code>capability</code>
		  attribute.
		</para>

		<para>
		  If no suitable application matching the criteria is running
		  can be identified, the expectation is that the control
		  application C will attempt to start a suitable application.
		</para>

		<para>
		  Rationale: because of the need to
		  facilitate e2e encryption, commands cannot be proxied through
		  control applications; the <code>find</code> request allows
		  clients to initiate a transfer to an application that might
		  not yet be running on the target device (i.e., C will take
		  care of spawning a suitable client if one is not available).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </section>

      <section xml:id="messaging-commands-iq-result">
	<title>Replies</title>

	<para>
	  All received <code>set</code> and <code>get</code> nScreen messages
	  queries must be explicitely acknowledged by the recipient. Success is
	  indicated using an <code>&lt;iq&gt;</code> stanza of type
	  <code>result</code>, while stanzas of type <code>error</code> are used
	  to indicate failure.
	</para>

	<para>
	  Depending on the nature of the original <code>&lt;iq&gt;</code>
	  <code>get</code> / <code>set</code> stanza, returned stanza of type
	  <code>result</code> might, or might not hold additional information
	  using one of the following xml elements:

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>&lt;nscreen:find-result&gt;</code>
	      </term>
	      <listitem>
		<para>
		  Reply to a previous <code>find</code> query that was
		  successfully resolved. The identified application jid is
		  stored in the <code>jid</code> attribute.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<para>
	  Returned stanzas of type <code>error</code> should include additional
	  information as to the nature of the error, using the XMPP
	  <code>&lt;error&gt;</code> container with the standard
	  <code>urn:ietf:params:xml:ns:xmpp-stanzas</code> namespace.

<annotation role='todo'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    Define some common error conditions here and types.

    Can we manage with not defining our own error condition namespace ?
  </para>
</annotation>
	</para>
      </section>

      <section xml:id="messaging-commands-attributes">
	<title>Common Attributes for nScreen message elements</title>


	<para>
	  The following attributes are used by the nScreen messages:

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>version</code>
	      </term>
	      <listitem>
		<para>
		  The nscreen protocol version, this attribute is required on
		  all top-level nScreen elements.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>time</code>
	      </term>
	      <listitem>
		<para>
		  Time of message dispatch, in standard XMPP
		  format<citation><xref linkend="xep0082"/></citation>, with at
		  least millisecond precision.
	      </para>
	    </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </section>

      <section xml:id="messaging-commands-example">
	<title>Command example</title>

	<para>
	  The following xml snippet tells some other application to start
	  playing given video starting 3/4 into the video duration:
	</para>

	<programlisting><![CDATA[
<iq type='set'
    id='command1'
    to='magic-video-player@blackbox.local'
    xmlns='nscreen::message'>

  <nscreen:command version='1.0'
                   time='1970-01-01T00:00:00.000Z'
                   capability='ns-caps-video'
                   activity='ns-activity-play'
                   uri='some random youtube url'
                   progress='0.75'>
        [Optional command data; binary data base64 encoded]
  </nscreen:command>
</iq>

 ...

<iq type='result'
    id='command1'
    to='the-other-player@bluebox.local'
    from='magic-video-player@blackbox.local'
    xmlns='nscreen::message'>

  <success/>
</iq>]]>
	</programlisting>
      </section>
    </section>

    <section xml:id="messaging-metadata">
      <title>Common meta-data classes</title>

      <para>
	The canonical definition is given by the DTD (see Appendix A); the
	following information is extracted from the DTD for convenience.
      </para>


      <section xml:id="messaging-metadata-caps">
	<title>Common capability classes</title>

	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		ns-caps-audio: audio playback capabilities
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-caps-video: video playback capabilities
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-caps-image: image display capabilities
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-caps-html: html rendering capabilities
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-caps-control: control application
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<annotation role='comment'>
	    <info>
	      <authorinitials>tf</authorinitials>
	    </info>
	    <para>
	      More stuff should be added here; open to suggestions.
	    </para>
	  </annotation>

	<para>
	  Custom capabilities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom capabilities must not use
	  'ns-' prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-activity">
	<title>Common activity classes</title>

	<para>
	  Absence of the 'activity' attribute, or its empty value imply idle
	  state.

	  <itemizedlist>
	    <listitem>
	      <para>
		ns-activity-play: playback
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-activity-pause: paused state
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-activity-ffw: fast forward
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-activity-rwd: rewind
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		ns-activity-volume: volume adjustment
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<annotation role='comment'>
	  <info>
	    <authorinitials>tf</authorinitials>
	  </info>
	  <para>
	  More stuff should be added here, open to suggestions.
	  </para>
	</annotation>

	<para>
	  Custom activities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom activities must not use 'ns-'
	  prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-attributes">
	<title>Common attributes</title>

	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		uri: uri a of a resource associated with activity
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		uid: uid identifying resource associated with activity.

		<annotation role='comment'>
		  <info>
		    <authorinitials>tf</authorinitials>
		  </info>
		  <para>
		    The idea is being able to use something like, for example,
		    musicbrainz id to identify the resource, though in practice
		    this might be hard to extend beyond audio
		  </para>
		</annotation>
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		volume: volume level (floating point number from &lt;0,1&gt;)
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		progress: activity progress (floating point number from
		&lt;0,1&gt; this is the preferred way of passing information
		such as stream position.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		position: activity position (floating point number); NB:
		applications should use the 'progress' attribute whenever
		possible instead of 'position'.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		description: human readable description, suitable for
		presentation to user
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		jid: jabber id; primarily for use by messages with 'transfer'
		payload
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		speed: speed of activity (floating point number; 1.0 indicates
		'normal' speed)
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<para>
	  Custom attributes can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom attributes must not use 'ns-'
	  prefix.
	</para>
      </section>
    </section>

    <section xml:id="messaging-data-transfer">
      <title>Data Transfer Protocols</title>

      <para>
	This section defines standard data transfer protocols to be used by
	nScreen clients; this list does not restrict clients to these protocols
	alone, but sets out preferred protocols.
      </para>

      <section xml:id="messaging-data-transfer-files">
	<title>File Transfers</title>

	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		The preferred file transfer protocol is SI File
		Transfer<citation><xref linkend="xep0096"/></citation>; this
		protocol must be supported by all compliant nScreen clients.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		It is recommended that clients also implement Jingle
		File Transfer<citation><xref linkend="xep0234"/></citation>;
		this protocol is currently in experimental stage, but once it is
		reaches the draft stage, it will be adopted as the default file
		transfer protocol for nScreen clients.


		<annotation role='comment'>
		  <info>
		    <authorinitials>tf</authorinitials>
		  </info>
		  <para>
		    This has relatively limited practical impact on us, the
		    initial deployment will be Telepathy based, which presumably
		    will hide this distinction from us.
		  </para>
		</annotation>
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<annotation role='todo'>
	  <info>
	    <authorinitials>tf</authorinitials>
	  </info>
	  <para>
	    We should recommend protocols for data streaming, and specifically
	    mandate preferred protocols for streaming of video and audio in the
	    manner we mandate the File Transfers. Presumably around
	    Jingle<citation><xref linkend="xep0166"/></citation>.
	  </para>
	</annotation>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <appendix xml:id="appendix-dtd">
    <title>nScreen DTD</title>
    <programlisting>
<!-- The xi:include line must be aligned directly at the end of this comment,
     as any padding will end up in the final document !!! --><xi:include
    parse="text"
    href="./nscreen-protocol.xsd" />
    </programlisting>
  </appendix>

  <bibliography>
    <title>External Resources</title>

    <biblioentry xml:id="rfc3920">
      <bibliomisc>
      <link xlink:href="http://tools.ietf.org/html/rfc3920">RFC 3920</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="rfc3923">
      <bibliomisc>
      <link xlink:href="http://tools.ietf.org/html/rfc3923">RFC 3923</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0030">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0030.html">XEP-0060</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0050">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0050.html">XEP-0050</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0054">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0054.html">XEP-0054</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0060">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0060.html">XEP-0060</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0082">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0084.html">XEP-0082</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0084">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0084.html">XEP-0084</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0096">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0096.html">XEP-0096</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0115">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0115.html">XEP-0115</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0163">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0163.html">XEP-0163</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0166">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0166.html">XEP-0166</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0174">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0174.html">XEP-0174</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0234">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0234.html">XEP-0234</link>
      </bibliomisc>
    </biblioentry>

  </bibliography>
</article>
