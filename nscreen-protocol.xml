<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:xlink="http://www.w3.org/1999/xlink"
	 xml:id="nscreen-protocol" xml:lang="en" class="specification">
  <info>

    <title>nScreen Protocol Specification</title>
	<subtitle>Version 1.0</subtitle>

	<orgname>Intel Corporation</orgname>

    <author>
      <personname>
	<firstname>Tomas</firstname> <surname>Frydrych</surname>
<!--
      <affiliation>
        <orgname>Intel Corporation</orgname>
      </affiliation>
-->
      </personname>
      <email>tf@linux.intel.com</email>
    </author>

    <revhistory>
      <revision>
         <revnumber>0.1</revnumber>
         <date>22 October 2010</date>
         <revremark>Initial draft</revremark>
      </revision>
      <revision>
         <revnumber>0.2</revnumber>
         <date>27 October 2010</date>
         <revremark>
	   responding to first batch of comments from Will Thompson (Collabora)
	 </revremark>
      </revision>
    </revhistory>
  </info>

<?hard-pagebreak?>

  <section xml:id="intro">
    <title>Introduction</title>
    <para>
      Users often carry out similar activities on different devices, e.g., watch
      videos on a smart phone, laptop, or a TV set. However, as the user moves
      in time and space, the optimal choice of a device for any given activity
      might change: a smart phone might be the optimal video viewing platform
      while travelling on a train, but a TV set might be optimal in the comfort
      of one's living room.
    </para>

    <para>
      The nScreen framework aims to facilitates seamless transition of the
      user's activities as she moves around. It does so by providing a
      communication channels through which individual user-facing applications
      on distinct devices can cooperate and coordinate their discrete
      behaviours, and in so construct a dynamic and homogeneous experience
      spanning the devices involved.
    </para>

    <para>
      The activities for which consumers use computers are impossible to
      enumerate, and are set to evolve. Consequently the nScreen framework does
      not seek to narrowly define the activities and/or services that might fall
      withing its scope, nor it seeks to prescribe the ways in which such
      activities or tasks should be accomplished. Rather the nScreen framework
      is a set of generic protocols that can support new activities and services
      without the need to modify the core protocols.
    </para>

    <para>
      More specifically, the aims of the nScreen framework are as follows:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  To provide unified discovery, connection and transport mechanism that
	  could be utilised on a variety of hardware and software platforms by a
	  wide spectrum of user-facing applications,
	</para>
      </listitem>

      <listitem>
	<para>
	  To provide standard meta-data model to facilitate efficient
	  inter-application communication.
	</para>
      </listitem>
    </itemizedlist>

    <section xml:id="intro-usecases">
      <title>Service Models</title>

      <para>
	nScreen services fall into two broad categories:
      </para>

      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Subscription-based services: these are provided by discrete
	      entities, each operating their own nScreen server. nScreen users
	      connect to this server using credentials agreed with the service
	      provider, and interact with applications offered by the service
	      provider through their server.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Applications interacting within a home cloud: the home cloud use
	      case differs from the subscription service by the absence of a
	      central server; instead the cloud transparently fulfils the role
	      of a subscription-less server.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The nScreen framework aims to support both of these scenarios in a
	transparent manner.
      </para>

    </section>

    <section xml:id="intro-application-classes">
      <title>Application Classes</title>

      <para>
	nScreen applications can be divided into two broad classes:

	<itemizedlist>
	  <listitem>
	    <para>
	      Task-oriented applications: these are the principal participants
	      in the nScreen mesh. They are user-facing applications, such as
	      media players, that have been enriched by adding the nScreen
	      capabilities.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Control Applications: these provide background nScreen services on
	      an nScreen-enabled devices. Their principal purpose is to allow
	      task-oriented applications to direct their communications at a
	      device, rather than a specific task-oriented application on that
	      device, and to ensure that appropriate task-oriented application
	      is available (e.g., by spawning of suitable application on the
	      device in response to incoming requests).
	    </para>

	    <para>
	      While control applications can be purely background processes,
	      when provided with a suitable UI they can be used as generic
	      nScreen remote controls.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </section>

    <section xml:id="intro-metadata">
      <title>Meta-data model</title>

      <para>
	One of the key components of the nScreen framework is the meta-data
	model. The purpose of the nScreen protocols is to allow applications to
	exchange meta-data describing their activities in a way that would allow
	them to coordinate these across multiple devices and
	platforms. Consequently, the meta-data model must be:

	<itemizedlist>
	  <listitem>
	    <para>
	      Flexible and extensible, to allow use with new, innovative
	      applications,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Sufficiently standardised to allow common classes
	      of applications to talk to each other transparently.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	It is worth noting that the protocol does not aim to provide mechanisms
	for actual data transfers, though in some common and specific cases it
	mandates which other standard protocols should be used (see <xref
	linkend="messaging-data-transfer"/>).
      </para>

      <para>
	The nScreen meta-data is modelled as a pairing of a capability subject
	(representing a single application feature that is of interest to a
	user) and an activity predicate (a way in which the user can manipulate
	content tied to a specific capability). Both the capability and the
	activity in each specific pair can be further qualified by attributes;
	the resulting <code>{capability, activity, attributes}</code> tuple
	constitutes the elementary meta-data unit.
      </para>

      <para>
	The above described tuple is used in two distinct ways: to indicate
	present application state, and to encapsulate instructions about future
	desired state.
      </para>

      <para>
	In order to facilitate communication between common application classes,
	the protocol defines the subjects, verbs and attributes for common types
	of user activities. At the same time, new subjects, verbs and attributes
	can be defined and used by specialised applications.
      </para>

      <para>
	In addition to the meta-data describing application activities, the
	protocol also specifies means through which application describe
	themselves to the user.
      </para>

      <para>
	(For full XML definition see <xref linkend="appendix-dtd"/>.)
      </para>
    </section>

    <section xml:id="intro-xmpp">
      <title>XMPP backbone</title>

      <para>
	The nScreen communication protocols are built on the existing XMPP (aka
	'jabber') standard. The reasons for choosing XMPP as the basic transport
	protocol are:

	<itemizedlist>
	  <listitem>
	    <para>
	      Using an established standard means that much of the wheel needs
	      not to be reinvented,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is supported on a broad range of hardware and software
	      platforms, thus aiding the speed with which the nScreen framework
	      can be rolled out,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is an open standard that can be used without difficulties
	      over licensing,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is extensible by design,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is capable of operating both in a server-based and
	      server-less manner, and supports both of these modes a in
	      transparent way,
	    </para>
	  </listitem>


	  <listitem>
	    <para>
	      XMPP is XML-based, so that implementation of extensions is
	      simplified by being able to use standard XML-processing tools,
	      such a parsers, etc.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	As far as possible, the nScreen framework aims to reusing existing XMPP
	capabilities and features; these are augmented by two extensions:

	<itemizedlist>
	  <listitem>
	    <para>
	      Protocols for encoding of nScreen meta-data,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A server-less protocol similar to link-local XMPP<citation><xref
	      linkend="xep0174"/></citation> , but reserved for nScreen use.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	In addition, at number of points, the nScreen specification mandates
	the use of standard, but optional, XMPP features, particularly so, where
	this is desirable to improve security and privacy.
      </para>
    </section>
  </section>

  <?hard-pagebreak?>

  <section xml:id="security">
    <title>Security and Privacy Considerations</title>

    <para>
      The flexible and extensible nature of the nScreen framework means that it
      is not possible to predict what kind of data may be transmitted via the
      protocol in its real-world deployment. Furthermore, the expectation of
      deployment on a variety of platforms, ranging from desktop computers to
      mobile phones, means that multiple implementations of the protocol will be
      in use. It is, therefore, important that security and privacy of user data
      is a key factor in the design of the protocol itself. More specifically:

      <itemizedlist>
	<listitem>
	  <para>
	    The protocol must facilitate privacy of data in transit where that
	    is appropriate or required,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Reliable identity verification mechanism must be available,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The protocol must provide structured access control to user's
	    local resources.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      With regards to the above, the following should be noted in particular:

      <itemizedlist>
	<listitem>
	  <para>
	    XMPP on its on only provides client-to-server privacy. As such XMPP
	    exchanges that span multiple servers are susceptible to server
	    eavesdropping; the practical implications of this are addressed in
	    <xref linkend="comm-protocols-privacy"/>,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Normal XMPP presence information is broadcast across all subscribed
	    contacts, and, in the case of link-local XMPP protocol, advertised
	    entirely openly via m-DNS broadcasts; consequently the protocol
	    avoids using the presence mechanism for meta-data exchanges,
	    including the extended status information (see <xref
	    linkend="messaging-status"/>).
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      The nScreen protocol specifies two sets of features aiming to ensure
      privacy of user data: the use of TLS (see <xref
      linkend="comm-protocols-privacy-tls"/>), and the use of end-to-end
      encryption (see <xref linkend="comm-protocols-privacy-e2e"/>).
    </para>

  </section>

<?hard-pagebreak?>
  <section xml:id="comm-protocols">
    <title>Communication Backbone Protocols</title>

      <section xml:id="comm-protocols-jid">
	<title>nScreen JID</title>

	<para>
	  All nScreen applications, regardless whether running in server-based
	  or server-less context, are identified using a bare XMPP
	  JID<citation><xref linkend="rfc3920"/></citation>. A single
	  application connection to the nScreen mesh is identified by a fully
	  qualified JID, consisting of a bare JID identifying the application
	  and a resource identifier; multiple simultaneous connections by single
	  application are permitted and differentiated by the resource part of
	  the fully qualified JID (an example of a bare JID would be
	  <code>application@somewhere.com</code> while a fully qualified JID
	  would be <code>application@somewhere.com/myresource</code>.
	</para>

	<para>
	  (In the remainder of this document, the term 'JID' is used to refer
	  to bare JIDs; if a fully qualified jabber id is meant, this will
	  always be explicitly stated.)
	</para>
      </section>

      <section xml:id="comm-protocols-authentication">
	<title>Authentication</title>

	<para>
	  Authentication is accomplished via SASL per core XMPP
	  protocol (<citation><xref linkend="rfc3920"/></citation>,
	  <citation><xref linkend="rfc2222"/></citation>). SASL authentication
	  must be implemented both for both server-based and server-less
	  contexts.
	</para>
      </section>

      <section xml:id="comm-protocols-identity">
	<title>
	  Identity Verification
	</title>

	<section xml:id="comm-protocols-identity-server">
	  <title>Identity Verification in Server-Based Context</title>

	  <para>
	    Standard XMPP does not provide a formal mechanism for identity
	    verification. Because the authentication of two communicating users,
	    A and B, is typically done separately and independently by two
	    different servers, A's trust in B's identity implies A's trust in
	    the authentication procedures of B's service provider, which cannot
	    be automatically granted.  Therefore, this generic scenario is only
	    acceptable if data exchanged between A and B contains no sensitive
	    information, i.e., for what essentially amounts to an anonymous
	    nScreen service.
	  </para>

	  <para>
	    Though there might be numerous nScreen applications for which an
	    anonymous service is entirely appropriate, an nScreen service that
	    requires reliable identity verification must either implement
	    additional identity verification measures beyond what is specified
	    by the current version of the protocol, or be implemented using a
	    dedicated nScreen server that requires direct login, and does not
	    permit server hops (i.e., both A and B are logging into the same
	    server in order to talk to each other). In this situation the
	    service provider is fully in control of the authentication
	    procedure, and, assuming 1:1 mapping between users and their
	    authentication credentials is in place, successful authentication
	    provides also for identity verification.
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-cloud">
	  <title>Identity Verification in Server-Less Context</title>

	  <para>
	    In server-less context of a home cloud, the 1:1 mapping between
	    nScreen users and authentication credentials cannot be guaranteed; a
	    simple home cloud set up might rely on a shared secret to allow
	    applications across the cloud to authenticate, which in turn allows
	    an authenticated application to spoof another application.
	  </para>

	  <para>
	    Although identity spoofing carries with it lesser risks in the
	    context of the home cloud, the following measures are required to be
	    taken by compliant nScreen implementations to improve security:

	    <itemizedlist>
	      <listitem>
		<para>
		  Applications must not make assumptions about identity of other
		  nScreen participants in the cloud context, unless they
		  implement additional identity verification procedures not
		  specified by the current version of the nScreen protocol,
		</para>
	      </listitem>

	      <listitem>
		<para>
		  Applications running both in server-based and server-less
		  contexts must not inject data from server-based streams into
		  the cloud and vice versa.
		</para>
	      </listitem>
	    </itemizedlist>
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-future">
	  <title>Future Expectations</title>

	  <para>
	    Additional identity verification mechanism addressing the current
	    limitations, using technologies such as PKI, will be defined in
	    future versions of the protocol.
	  </para>
	</section>
      </section>

      <section xml:id="comm-protocols-subscription">
	<title>Subscription</title>

	<para>
	  The nScreen framework uses a subscription mechanism to provide access
	  control between nScreen applications; the details of the subscription
	  mechanism vary between the server-based and server-less modes of
	  operation.
	</para>

	<section xml:id="comm-protocols-server-subscription">
	  <title>Server-end subscription</title>

	  <para>
	    Server-based nScreen services must implement standard subscription
	    mechanism as set out by the core XMPP protocol<citation><xref
	    linkend="rfc3920"/></citation> and must comply with the subscription
	    policies the core specification sets out.
	  </para>

	  <para>
	    Available outward facing services to which users can subscribe
	    should be advertised by the server via XMPP Service Discovery
	    mechanism <citation><xref linkend="xep0030"/></citation>.
	  </para>
	</section>

	<section xml:id="comm-protocols-local-subscription">
	  <title>Subscription in server-less context</title>

	  <para>
	    The standard, server-centric, XMPP subscription mechanism is not
	    applicable for the link-local set up; in order to circumvent this
	    limitation, the local-nscreen protocol specification defined later
	    in this document (see <xref linkend="local-nscreen"/>), defines a
	    separate subscription mechanism to use in its place.
	  </para>
	</section>

    </section>

    <section xml:id="comm-protocols-privacy">
      <title>Privacy Protocols</title>

      <section xml:id="comm-protocols-privacy-tls">
	<title>TLS</title>

	<para>
	  Compliant nScreen applications, both servers and clients, must
	  support TLS as specified by the core XMPP protocol <citation><xref
	  linkend="rfc3920"/></citation>, and must use TLS secured
	  connections exclusively, both for client-to-server and
	  server-to-server connections; both compliant servers and clients are
	  required to refuse connections that do not use TLS.
	</para>

	<para>
	  It should be noted here again that the use of TLS on its own does not
	  prevent server eavesdropping when the XMPP conversation spans multiple
	  servers. nScreen applications needing to transmit highly sensitive
	  data should either use single-server XMPP exchanges along the lines
	  described in <xref linkend="comm-protocols-identity-server"/>, or
	  otherwise will have to make use of end-to-end encryption.
	</para>

      </section>

      <section xml:id="comm-protocols-privacy-e2e">
	<title>End to end encryption</title>

	<para>
	  The end-to-end encryption to be used by nScreen clients is described
	  by the XMPP e2e extension <citation><xref
	  linkend="rfc3923"/></citation>.

	  <annotation role="comment">
	    <info>
	      <authorinitials>tf</authorinitials>
	    </info>
	    <para>
	      Ideally, some form of e2e TLS channel for exchange of presence and
	      messages would be preferable, the support for which the XMPP group
	      is looking into<citation><xref
	      linkend="jng-xtls"/></citation>. The xep-e2e will do in principle;
	      it is worth noting that it is unlikely to be used because entities
	      requiring this level of privacy will have to use a dedicated
	      nScreen server for identity verification, in which case the TLS
	      provides complete privacy of data in transit, rendering e2e
	      superfluous.
	    </para>
	  </annotation>

	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="local-nscreen">
      <title>Local-nscreen protocol</title>

      <para>
	The local-nscreen protocol allows for automatic connection between
	nScreen clients running on the same LAN. It is derived from the
	local-xmpp protocol, but with some differences:

	<annotation role="comment">
	  <info>
	    <authorinitials>wt</authorinitials>
	  </info>
	  <para>
	    Should be possible to support in salut using a connection parameter.
	  </para>
	</annotation>

	<itemizedlist>
	  <listitem>
	    <para>
	      The link-local service is called 'nscreen' rather than 'presence',
	      i.e., the PTRs have pattern 'JID._nscreen._tcp._local.',
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Connection is done by JID and resource as with regular XMPP; the
	      JID part before the '@' symbol is provided explicitly to the
	      connection manager, the server part after '@' is worked out
	      automatically by the connection manager.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The connection manager implements a subscription mechanism
	      described below (<xref linkend="local-nscreen-subscription"/>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      All implementations must support SASL authentication.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <section xml:id="local-nscreen-subscription">
	<title>Subscription mechanism</title>

	<para>
	  Standard XMPP subscription is implemented exchanging
	  <code>&lt;presence&gt;</code> stanzas. However, the link-local version
	  of XMPP<citation><xref linkend="xep0174"/></citation> uses m-DNS
	  broadcast to distribute presence information, which makes it
	  unsuitable for exchanging client-specific
	  <code>&lt;presence&gt;</code> stanzas, so a different mechanism for
	  establishing subscription is needed.
	</para>

	<para>
	  At the same time, it is desirable that the alternative subscription
	  mechanism would be functionally equivalent to standard XMPP
	  subscription so that any user-level APIs could be identical for both
	  the server-based and server-less scenarios. To this end, the
	  local-nscreen protocol defines a thin layer allowing the relevant
	  <code>&lt;presence&gt;</code> stanzas to be delivered independently of
	  the m-DNS presence broadcasts.
	</para>

	<para>
	  The local-nscreen subscription handshake is carried out by exchanging
	  <code>&lt;iq&gt;</code> <code>set</code> stanzas using
	  <code>urn:nscreen:local-subscription</code> namespace. These
	  <code>&lt;iq&gt;</code> stanzas provide a wrapper around appropriate
	  <code>&lt;presence&gt;</code> stanzas as used by the standard XMPP
	  subscription mechanism, so that a local-nscreen subscription exchange
	  can be converted into a standard XMPP subscription exchange by simply
	  stripping out the external <code>&lt;iq&gt;</code> layer.
	</para>

	<para>
	  Compliant local-nscreen connection managers are required to implement
	  this mechanism.
	</para>

<annotation role='comment'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    The initial Telepathy implementation of this protocol might not implement
    this functionality, deferring it to a second iteration; based on the
    experiences with the initial implementation, this, and other, parts of this
    specification might need to be tuned.
  </para>
</annotation>
      </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="messaging">
    <title>Messaging Protocols</title>

    <section xml:id="messaging-app-info">
      <title>Descriptive Application Information</title>

      <para>
	nScreen applications need to provide descriptive information about
	themselves that can be presented to the user. At the bare minimum, this
	information includes a suitable, localised, application name.
      </para>
      <para>
	The mechanism for obtaining descriptive application information is XMPP
	Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>; the descriptive information is contained
	in a <code>&lt;identity&gt;</code> element of <code>category</code>
	'client'. Two new types are defined for use with this category:
	<code>'nscreen-application'</code> and
	<code>'nscreen-controller'</code>, corresponding to task-oriented and
	control applications respectively (see <xref
	linkend="intro-application-classes"/>).
      </para>

<annotation role='comment'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    I assume this will work in server-less context?
  </para>
</annotation>

      <para>
	The <code>name</code> attribute of the <code>&lt;identity&gt;</code>
	element holds application name, while the <code>xml:lang</code>
	attribute identifies the locale used by the <code>name</code>
	attribute. As per XMPP Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>, the query reply may include multiple
	<code>&lt;identity&gt;</code> elements of the same category and type,
	but with different <code>xml:lang</code> attribute. However, if the
	<code>&lt;query&gt;</code> of the original request has an explicit
	<code>xml:lang</code> attribute, the reply contents should be filtered
	by that attribute. If the <code>xml:lang</code> attribute of the
	<code>&lt;query&gt;</code> cannot be matched the respondent may return
	either a suitable fall-back, or all available translations.
      </para>

      <para>
	(For full description of the XML elements, see <xref
	linkend="appendix-dtd"/>).
      </para>

      <section xml:id="messaging-app-info-example">
	<title>Application Information XML example</title>

	<programlisting language="xml"><![CDATA[
<iq to="icecream-maker@custom-foods.com/resource"
    type="get"
    id="appinfo1">

  <query xmlns='http://jabber.org/protocol/disco#info'/
         xml:lang="en-GB"/>

</iq>

 ...

<iq to="a.customer@custom-foods.com/resource"
    type="result"
    id="appinfo1">

  <identity category='client'
            type='nscreen-application'
            name='Magic Icecream Maker'
	    xml:lang='en-GB'/>

</iq>]]>
	</programlisting>
      </section>

    </section>

    <section xml:id="messaging-app-caps">
      <title>Application Capabilities</title>

      <para>
	nScreen applications advertise their capabilities via XMPP Entity
	Capabilities protocol<citation><xref linkend="xep0115"/></citation>,
	using <code>urn:nscreen:capabilities</code> as the value of the
	<code>node</code> attribute of the <code>&lt;c&gt;</code> element.
      </para>

      <para>
	Each individual capability is represented by the
	<code>&lt;feature&gt;</code> element; the <code>var</code> attribute is
	constructed by concatenating an <code>'urn:nscreen:capabilies:'</code>
	prefix and the canonical name of the capabality (i.e., for standard
	capabilities, as defined in <xref
	linkend="messaging-metadata-caps"/>). For example, a video playback
	capability would be represented as:
      </para>

      <programlisting><![CDATA[
<feature var='urn:nscreen:capabilities:ns-caps-video' />

]]></programlisting>
    </section>

    <section xml:id="messaging-status">
      <title>Extended Status</title>

      <para>
	Extended status information is advertised using XMPP Personal Eventing
	Protocol<citation><xref linkend="xep0163"/></citation>. The status
	payload is held by an <code>&lt;nscreen:status&gt;</code> element and
	its attributes; applications with multiple capabilites must include
	an <code>&lt;nscreen:status&gt;</code> element for each capability.
      </para>

      <para>
	The following attributes, in addition to those defined in <xref
	linkend="messaging-metadata-attributes"/>, are used with the
	<code>&lt;nscreen:status&gt;</code> element:

	<variablelist>
	  <varlistentry>
	    <term><code>version</code></term>

	    <listitem>
	      <para>
		nScreen protocol version; required,
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>capability</code></term>

	    <listitem>
	      <para>
		The capability this status applies to; required. The value
		should be preferably one of those defined in <xref
		linkend="messaging-metadata-caps"/>,
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>activity</code></term>

	    <listitem>
	      <para>
		The activity this status represents; optional, if not present
		<code>ns-activity-idle</code> is implied. The value should be
		preferably one of those defined in <xref
		linkend="messaging-metadata-activity"/>
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>primary-capability</code></term>

	    <listitem>
	      <para>
		boolean indicating whether capability this status applies to is
		the primary capability of the application; optional, if absent
		<code>false</code> is implied.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>
      </para>

      <para>
	While the <code>&lt;nscreen:status&gt;</code> element can be extended
	with custom attributes, no frequently changing information
	(such as current playback position) is permitted as part of status to
	avoid flooding of the network.
      </para>

      <para>
	Human readable description is provided using one or more
	<code>&lt;nscreen:description&gt;</code> elements inside the
	<code>&lt;nscreen:status&gt;</code> element; each
	<code>&lt;nscreen:description&gt;</code> element must have an
	<code>xml:lang</code> attribute, and multiple
	<code>&lt;nscreen:description&gt;</code> elements must have a different
	<code>xml:lang</code> attribute each.
      </para>

      <section xml:id="messaging-status-avatars">
	<title>Support for Avatars</title>

	<para>
	  In addition to the extended status mechanism described above, it is
	  recommended that all nScreen implementations support the XMPP User
	  Avatar specification<citation><xref linkend="xep0084"/></citation>.
	</para>
      </section>

      <section xml:id="messaging-status-example">
	<title>Status XML example</title>

	<programlisting><![CDATA[
<nscreen:status version='1.0'
                capability='ns-caps-video'
                activity='ns-activity-play'
                uri='some random youtube url'
                volume='0.75'>

  <nscreen:description xml:lang='en-GB'>
    Playing a video about colour-based optical illusions.
  </nscreen:description>

</nscreen:status>]]>
	</programlisting>
      </section>
    </section>

    <section xml:id="messaging-commands">
      <title>Instruction Messages</title>

      <para>
	Instruction messages are used to send nScreen commands and information
	queries. The protocol defines a set of generic XML elements that are
	used to encapsulate nScreen messages, with parameters transmitted via
	XML attributes.
      </para>

      <para>
	The messages per se are exchanged using XMPP <code>&lt;iq&gt;</code>
	stanzas, with xmlns of 'urn:nscreen:message'. Commands are dispatched
	using <code>&lt;iq&gt;</code> stanza of type <code>set</code>, while
	information requests are sent using type <code>get</code>. All
	<code>get</code> / <code>set</code> requests are acknowledged by the
	recipient using <code>&lt;iq&gt;</code> stanzas of type
	<code>result</code> or <code>error</code>.
      </para>

      <section xml:id="messaging-commands-iq-set">
	<title>Commands</title>

	<para>
	  Commands use <code>set</code> type <code>&lt;iq&gt;</code> stanzas;
	  the command payload is carried by one of the following XML elements.
	</para>

	<section xml:id="messaging-commands-command">
	  <title><code>&lt;nscreen:command&gt;</code></title>

	  <para>
	    A command sent from application A to application B to executed
	    directly by application B.
	  </para>
	  <para>
	    Required attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>version</code>
		</term>
		<listitem>
		  <para>
		    The nscreen protocol version.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>capability</code>
		</term>
		<listitem>
		  <para>
		    Capability on which the command is to operate, preferably
		    using one of the values defined in <xref
		    linkend="messaging-metadata-caps"/>.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>activity</code>
		</term>
		<listitem>
		  <para>
		    Activity to carry out, preferably using one of the values
		    defined in <xref linkend="messaging-metadata-activity"/>.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>time</code>
		</term>
		<listitem>
		  <para>
		    Time of command dispatch in standard XMPP
		    format<citation><xref linkend="xep0082"/></citation>, with
		    at least millisecond precision.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Additional attributes, preferably using those defined in <xref
	    linkend="messaging-metadata-attributes"/>, are used to further
	    qualify the capability and activity specified.
	  </para>
	</section>

	<section xml:id="messaging-commands-transfer">
	  <title><code>&lt;nscreen:transfer&gt;</code></title>

	  <para>
	    A request by application A to application B to transfer B's activity
	    to application C.
	  </para>

	  <para>
	    Required attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>version</code>
		</term>
		<listitem>
		  <para>
		    The nscreen protocol version.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>capability</code>
		</term>
		<listitem>
		  <para>
		    Capability that is subject of the transfer.
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>jid</code>
		</term>
		<listitem>
		  <para>
		    JID of the application to transfer to.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Additional attributes, preferably using those defined in <xref
	    linkend="messaging-metadata-attributes"/>, may be used to further
	    qualify the capability specified.
	  </para>

	</section>

      </section>

      <section xml:id="messaging-commands-iq-get">
	<title>Information requests</title>

	<para>
	  Information requests use <code>get</code> type <code>&lt;iq&gt;</code>
	  stanzas; the command payload is carried by one of the following XML
	  elements.
	</para>

	<section xml:id="messaging-commands-find">
	  <title><code>&lt;nscreen:find&gt;</code></title>

	  <para>
	    A request by application A to a control application C to identify
	    suitable application B to dispatch a (subsequent) command to. The
	    criteria for the search is given by the supplied attributes, (e.g.,
	    application capability would be specified using the
	    <code>capability</code> attribute); the control application returns
	    the result of the search using the
	    <code>&lt;nscreen:find-result&gt;</code> element (see <xref
	    linkend="messaging-commands-find-result"/>.
	  </para>

	  <para>
	    If no suitable running application matching the specified criteria
	    can be identified, the control application C must return immediately
	    an error of type <code>wait</code>, then attempt to start a suitable
	    application. When the application successfully starts up, the control
	    application must dispatch the
	    <code>&lt;nscreen:find-result&gt;</code> response, with an identical
	    <code>id</code>attribute of the <code>&lt;iq&gt;</code> query. If
	    the application fails to start, the control application should
	    return error of type <code>unavailable</code>, again with an
	    identical <code>id</code>attribute of the <code>&lt;iq&gt;</code>
	    query.
	  </para>

	  <para>
	    Rationale: because of the need to
	    facilitate e2e encryption, commands cannot be proxied through
	    control applications; the <code>find</code> request allows
	    clients to initiate a transfer to an application that might
	    not yet be running on the target device.
	  </para>
	</section>
      </section>

      <section xml:id="messaging-commands-iq-result">
	<title>Replies</title>

	<para>
	  All received <code>set</code> and <code>get</code> nScreen messages
	  queries must be explicitly acknowledged by the recipient. Success is
	  indicated using an <code>&lt;iq&gt;</code> stanza of type
	  <code>result</code>, while stanzas of type <code>error</code> are used
	  to indicate failure.
	</para>

	<para>
	  Depending on the nature of the original <code>&lt;iq&gt;</code>
	  <code>get</code> / <code>set</code> stanza, returned stanza might, or might not hold additional information
	  using one of the following XML elements.
	</para>

	<section xml:id="messaging-commands-find-result">
	  <title><code>&lt;nscreen:find-result&gt;</code></title>

	  <para>
	    Reply to a previous <code>find</code> query that was successfully
	    resolved. The identified application JID is stored in the
	    <code>jid</code> attribute.
	  </para>
	</section>

	<section xml:id="messaging-commands-errors">
	  <title><code>&lt;error&gt;</code></title>

	  <para>
	    Returned stanzas of type <code>error</code> should include
	    additional information as to the nature of the error, using the XMPP
	    <code>&lt;error&gt;</code> container with the standard
	    <code>urn:ietf:params:xml:ns:xmpp-stanzas</code> namespace.

<annotation role='todo'>
  <info>
    <authorinitials>tf</authorinitials>
  </info>
  <para>
    Define some common error conditions here and types.

    Can we manage with not defining our own error condition namespace ?
  </para>
</annotation>
	  </para>
	</section>
      </section>

      <section xml:id="messaging-commands-example">
	<title>Command example</title>

	<para>
	  The following XML snippet tells some other application to start
	  playing given video starting 3/4 into the video duration:
	</para>

	<programlisting><![CDATA[
<iq type='set'
    id='command1'
    to='magic-video-player@blackbox.local'
    xmlns='urn:nscreen:message'>

  <nscreen:command version='1.0'
                   time='1970-01-01T00:00:00.000Z'
                   capability='ns-caps-video'
                   activity='ns-activity-play'
                   uri='some random youtube url'
                   progress='0.75'>
        [Optional command data; binary data base64 encoded]
  </nscreen:command>
</iq>

 ...

<iq type='result'
    id='command1'
    to='the-other-player@bluebox.local'
    from='magic-video-player@blackbox.local'
    xmlns='urn:nscreen:message'>

  <success/>
</iq>]]>
	</programlisting>
      </section>
    </section>

    <section xml:id="messaging-metadata">
      <title>Common meta-data classes</title>

      <para>
	The canonical definition is given by the DTD (see Appendix A); the
	following information is extracted from the DTD for convenience.
      </para>


      <section xml:id="messaging-metadata-caps">
	<title>Common capability classes</title>

	<para>
	  <variablelist>
	    <varlistentry>
	      <term>
		<code>ns-caps-audio</code>
	      </term>

	      <listitem>
		<para>
		  audio playback capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-video</code>
	      </term>

	      <listitem>
		<para>
		  video playback capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-image</code>
	      </term>

	      <listitem>
		<para>
		  image display capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-html</code>
	      </term>

	      <listitem>
		<para>
		  html rendering capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-control</code>
	      </term>

	      <listitem>
		<para>
		  control application.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<annotation role='comment'>
	    <info>
	      <authorinitials>tf</authorinitials>
	    </info>
	    <para>
	      More stuff should be added here; open to suggestions.
	    </para>
	  </annotation>

	<para>
	  Custom capabilities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom capabilities must not use
	  'ns-' prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-activity">
	<title>Common activity classes</title>

	<para>
	  Absence of the 'activity' attribute, or its empty value imply idle
	  state.

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>ns-activity-playback</code>
	      </term>

	      <listitem>
		<para>
		  playback,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-pause</code>
	      </term>
	      <listitem>
		<para>
		  paused state,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-ffw</code>
	      </term>
	      <listitem>
		<para>
		  fast forward,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-rwd</code>
	      </term>
	      <listitem>
		<para>
		  rewind,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-volume</code>
	      </term>
	      <listitem>
		<para>
		  volume adjustment.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<annotation role='comment'>
	  <info>
	    <authorinitials>tf</authorinitials>
	  </info>
	  <para>
	  More stuff should be added here, open to suggestions.
	  </para>
	</annotation>

	<para>
	  Custom activities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom activities must not use 'ns-'
	  prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-attributes">
	<title>Common attributes</title>

	<para>
	  <variablelist>
	    <varlistentry>
	      <term><code>uri</code></term>

	      <listitem>
		<para>
		  <code>uri</code> a of a resource associated with activity;
		  this can be either a <code>url</code> from which the resource
		  can be fetched, or a <code>urn</code> identifying a suitable
		  protocol through which the resource can be obtained directly
		  from the initiating application (e.g.,
		  <code>urn:xmpp:jingle:apps:rtp:video</code> would indicate a
		  video is to be streamed using the Jingle RTP protocol).
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>uid</code></term>

	      <listitem>
		<para>
		  uid: uid identifying resource associated with activity.

		<annotation role='comment'>
		  <info>
		    <authorinitials>tf</authorinitials>
		  </info>
		  <para>
		    The idea is being able to use something like, for example,
		    musicbrainz id to identify the resource, though in practice
		    this might be hard to extend beyond audio
		  </para>
		</annotation>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>volume</code></term>

	      <listitem>
		<para>
		  volume level (floating point number from &lt;0,1&gt;)
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>progress</code></term>

	    <listitem>
	      <para>
		activity progress (floating point number from
		&lt;0,1&gt; this is the preferred way of passing information
		such as stream position.
	      </para>
	    </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>position</code></term>

	      <listitem>
		<para>
		  activity position (floating point number); NB: applications
		  should use the <code>progress</code> attribute whenever
		  possible instead of 'position',
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>description</code></term>

	      <listitem>
		<para>
		  description: human readable description, suitable for
		  presentation to user,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jid</code></term>

	      <listitem>
		<para>
		  jabber id,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>speed</code></term>

	      <listitem>
		<para>
		  speed of activity (floating point number; 1.0 indicates
		  normal speed)
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<para>
	  Custom attributes can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom attributes must not use 'ns-'
	  prefix.
	</para>
      </section>
    </section>

    <section xml:id="messaging-data-transfer">
      <title>Data Transfer Protocols</title>

      <para>
	This section defines standard data transfer protocols to be used by
	nScreen clients; this list does not restrict clients to these protocols
	alone, but sets out preferred protocols.
      </para>

      <section xml:id="messaging-data-transfer-files">
	<title>File Transfers</title>

	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		The preferred file transfer protocol is SI File
		Transfer<citation><xref linkend="xep0096"/></citation>; this
		protocol must be supported by all compliant nScreen clients.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		It is recommended that clients also implement Jingle
		File Transfer<citation><xref linkend="xep0234"/></citation>;
		this protocol is currently in experimental stage, but once it is
		reaches the draft stage, it will be adopted as the default file
		transfer protocol for nScreen clients.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </section>

      <section xml:id="messaging-data-transfer-streaming">
	<title>Streaming</title>

	<para>
	  The preferred streaming protocol is XMPP Jingle RTP<citation><xref
	  linkend="xep0167"/></citation>; applications that support media
	  streaming should implement this protocol.
	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <appendix xml:id="appendix-dtd">
    <title>nScreen DTD</title>
    <programlisting>
<!-- The xi:include line must be aligned directly at the end of this comment,
     as any padding will end up in the final document !!! --><xi:include
    parse="text"
    href="./nscreen-protocol.xsd" /></programlisting>
  </appendix>

  <bibliography>
    <title>External Resources</title>

    <biblioentry xml:id="jng-xtls">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/inbox/jingle-xtls.html">Jingle XTLS</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="rfc2222">
      <bibliomisc>
      <link xlink:href="http://tools.ietf.org/html/rfc2222">RFC 2222</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="rfc3920">
      <bibliomisc>
      <link xlink:href="http://tools.ietf.org/html/rfc3920">RFC 3920</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="rfc3921">
      <bibliomisc>
      <link xlink:href="http://tools.ietf.org/html/rfc3921">RFC 3921</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="rfc3923">
      <bibliomisc>
      <link xlink:href="http://tools.ietf.org/html/rfc3923">RFC 3923</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0030">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0030.html">XEP-0060</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0050">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0050.html">XEP-0050</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0054">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0054.html">XEP-0054</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0060">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0060.html">XEP-0060</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0082">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0084.html">XEP-0082</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0084">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0084.html">XEP-0084</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0096">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0096.html">XEP-0096</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0115">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0115.html">XEP-0115</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0163">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0163.html">XEP-0163</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0166">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0166.html">XEP-0166</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0167">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0167.html">XEP-0167</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0174">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0174.html">XEP-0174</link>
      </bibliomisc>
    </biblioentry>

    <biblioentry xml:id="xep0234">
      <bibliomisc>
      <link xlink:href="http://xmpp.org/extensions/xep-0234.html">XEP-0234</link>
      </bibliomisc>
    </biblioentry>

  </bibliography>
</article>
