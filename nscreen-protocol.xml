<?xml version="1.0" encoding="utf-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:xlink="http://www.w3.org/1999/xlink"
	 xml:id="nscreen-protocol" xml:lang="en" class="specification"
	 status="draft">
  <info>

    <title>nScreen Protocol Specification</title>
	<subtitle>Version 0.2</subtitle>

	<org>
	  <orgname>Intel Corporation</orgname>
	  <orgdiv>Open Source Technology Centre</orgdiv>
	</org>

    <author>
      <personname>
	<firstname>Tomas</firstname> <surname>Frydrych</surname>
<!--
      <affiliation>
        <orgname>Intel Corporation</orgname>
      </affiliation>
-->
      </personname>
      <email>tf@linux.intel.com</email>
    </author>

    <revhistory>
<!--
      <revision>
         <revnumber>0.1</revnumber>
         <date>22 October 2010</date>
         <revremark>Initial draft</revremark>
      </revision>
      <revision>
         <revnumber>0.2</revnumber>
         <date>27 October 2010</date>
         <revremark>
	   responding to comments from Will Thompson (Collabora)
	 </revremark>
      </revision>
      <revision>
         <revnumber>0.3</revnumber>
         <date>29 October 2010</date>
         <revremark>
	   tidying up loose ends
	 </revremark>
      </revision>
-->
      <revision>
         <revnumber>0.4</revnumber>
         <date>1 November 2010</date>
         <revremark>
	   Initial draft
	 </revremark>
      </revision>
      <revision>
         <revnumber>0.5</revnumber>
         <date>1 November 2010</date>
         <revremark>
	   ...
	 </revremark>
      </revision>
    </revhistory>

    <copyright>
      <year>2010</year>
      <holder>Intel Corporation</holder>
    </copyright>
  </info>

<?hard-pagebreak?>

  <section xml:id="intro">
    <title>Introduction</title>
    <para>
      Users often carry out similar activities on different devices, e.g., watch
      videos on a smart phone, laptop, or a TV set. However, as the user moves
      in time and space, the optimal choice of a device for any given activity
      might change: a smart phone might be the optimal video viewing platform
      while travelling on a train, but a TV set might be optimal in the comfort
      of one's living room.
    </para>

    <para>
      The nScreen framework aims to facilitates seamless transition of the
      user's activities as she moves around. It does so by providing a
      communication channels through which individual user-facing applications
      on distinct devices can cooperate and coordinate their discrete
      behaviours, and in so construct a dynamic and homogeneous experience
      spanning the devices involved.
    </para>

    <para>
      The activities for which consumers use computers are impossible to
      enumerate, and are set to evolve. Consequently the nScreen framework does
      not seek to narrowly define the activities and/or services that might fall
      withing its scope, nor it seeks to prescribe the ways in which such
      activities or tasks should be accomplished. Rather the nScreen framework
      is a set of generic protocols that can support new activities and services
      without the need to modify the core protocols.
    </para>

    <para>
      More specifically, the aims of the nScreen framework are as follows:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  To provide unified discovery, connection and transport mechanism that
	  could be utilised by user-facing applications running on a variety of
	  hardware and software platforms,
	</para>
      </listitem>

      <listitem>
	<para>
	  To provide standardised meta-data model to facilitate efficient
	  inter-application communication.
	</para>
      </listitem>
    </itemizedlist>

    <section xml:id="intro-usecases">
      <title>Service Models</title>

      <para>
	nScreen services fall into two broad categories:
      </para>

      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Subscription-based services: these are provided by discrete
	      entities, each operating their own nScreen server. nScreen users
	      connect to this server using credentials agreed with the service
	      provider, and interact with applications offered by the service
	      provider through their server.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Applications interacting within a home cloud: the home cloud use
	      case differs from the subscription service by the absence of a
	      central server; instead the cloud transparently fulfils the role
	      of a subscription-less server.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The nScreen framework aims to support both of these scenarios in a
	transparent manner.
      </para>

    </section>

    <section xml:id="intro-application-classes">
      <title>Application Classes</title>

      <para>
	nScreen applications can be divided into two broad classes:

	<itemizedlist>
	  <listitem>
	    <para>
	      Task-oriented applications: these are the core participants in the
	      nScreen mesh. They are user-facing applications, such as media
	      players, that have been enriched by adding the nScreen
	      capabilities.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Control Applications: these provide background nScreen services on
	      an nScreen-enabled devices. Their principal purpose is to allow
	      task-oriented applications to direct their communications at a
	      device, rather than a specific task-oriented application on that
	      device, and to ensure that appropriate task-oriented application
	      is available (e.g., by spawning of suitable application on the
	      device in response to incoming requests).
	    </para>

	    <para>
	      While control applications can be purely background processes,
	      when provided with a suitable UI they can be used as generic
	      nScreen remote controls.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </section>

    <section xml:id="intro-metadata">
      <title>Meta-data model</title>

      <para>
	One of the key components of the nScreen framework is the meta-data
	model. The purpose of the nScreen protocols is to allow applications to
	exchange meta-data describing their activities in a way that would allow
	them to coordinate these across multiple devices and
	platforms. Consequently, the meta-data model must be:

	<itemizedlist>
	  <listitem>
	    <para>
	      Flexible and extensible, to allow use with new, innovative
	      applications,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Sufficiently standardised to allow common classes
	      of applications to talk to each other transparently.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	It is worth noting that the protocol does not aim to provide mechanisms
	for actual data transfers, though in some common and specific cases it
	mandates which other standard protocols should be used (see <xref
	linkend="messaging-data-transfer"/>).
      </para>

      <para>
	The nScreen meta-data is modelled as a pairing of a capability subject
	(representing a single application feature that is of interest to a
	user) and an activity predicate (a way in which the user can manipulate
	content tied to a specific capability). Both the capability and the
	activity in each specific pair can be further qualified by attributes;
	the resulting <code>{capability, activity, attributes}</code> tuple
	constitutes the elementary unit of nScreen meta-data.
      </para>

      <para>
	The above described tuple is used in two distinct ways: to indicate
	present application state, and to encapsulate instructions about future
	desired state.
      </para>

      <para>
	In order to facilitate communication between common application classes,
	the protocol defines the subjects, verbs and attributes for common types
	of user activities. At the same time, new subjects, verbs and attributes
	can be defined and used by specialised applications.
      </para>

      <para>
	In addition to the meta-data describing application activities, the
	protocol also specifies means through which application describe
	themselves to the user.
      </para>
    </section>

    <section xml:id="intro-xmpp">
      <title>XMPP backbone</title>

      <para>
	The nScreen communication protocols are built on the existing XMPP
	standard. The reasons for choosing XMPP as the basic transport protocol
	are:

	<itemizedlist>
	  <listitem>
	    <para>
	      Using an established messaging standard means that much of the
	      wheel needs not to be reinvented,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is supported on a broad range of hardware and software
	      platforms, thus aiding the speed with which the nScreen framework
	      can be rolled out,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is an open standard that can be used without difficulties
	      over licensing,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is extensible by design,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      XMPP is capable of operating both in a server-based and
	      server-less manner, and supports both of these modes a in
	      transparent way,
	    </para>
	  </listitem>


	  <listitem>
	    <para>
	      XMPP is XML-based, so that implementation of extensions is
	      simplified by being able to use standard XML-processing tools,
	      such a parsers, etc.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	As far as possible, the nScreen framework aims to reuse existing XMPP
	capabilities and features; these are augmented by two extensions:

	<itemizedlist>
	  <listitem>
	    <para>
	      Protocols for encoding of nScreen meta-data,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A server-less protocol similar to link-local XMPP<citation><xref
	      linkend="xep0174"/></citation> , but tailored for nScreen use.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	In addition, at number of points, the nScreen specification mandates
	the use of standard, but optional, XMPP features, particularly so, where
	this is desirable to improve security and privacy.
      </para>
    </section>
  </section>

  <?hard-pagebreak?>

  <section xml:id="security">
    <title>Security and Privacy Considerations</title>

    <para>
      The flexible and extensible nature of the nScreen framework means that it
      is not possible to predict what kind of data may be transmitted via the
      protocol in its real-world deployment. Furthermore, the expectation of
      deployment on a variety of platforms, ranging from desktop computers to
      mobile phones, means that multiple implementations of the protocol will be
      in use. It is, therefore, important that security and privacy of user data
      is a key factor in the design of the protocol itself. More specifically:

      <itemizedlist>
	<listitem>
	  <para>
	    The protocol must facilitate privacy of data in transit where that
	    is appropriate or required,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Reliable identity verification mechanism must be available,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The protocol must provide structured access control to user's
	    local resources.
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      With regards to the above, the following should be noted in particular:

      <itemizedlist>
	<listitem>
	  <para>
	    XMPP on its on only provides client-to-server privacy. As such XMPP
	    exchanges that span multiple servers are susceptible to server
	    eavesdropping; the practical implications of this are addressed in
	    <xref linkend="comm-protocols-privacy"/>,
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Normal XMPP presence information is broadcast across all subscribed
	    contacts, or, in the case of link-local XMPP protocol, even
	    advertised entirely openly via m-DNS broadcasts; consequently the
	    protocol avoids using the presence mechanism for meta-data
	    exchanges, including the extended status information (see <xref
	    linkend="messaging-status"/>).
	  </para>
	</listitem>
      </itemizedlist>
    </para>

    <para>
      The nScreen protocol specifies two sets of features aiming to ensure
      privacy of user data: the use of TLS (see <xref
      linkend="comm-protocols-privacy-tls"/>), and the use of end-to-end
      encryption (see <xref linkend="comm-protocols-privacy-e2e"/>).
    </para>

  </section>

<?hard-pagebreak?>
  <section xml:id="comm-protocols">
    <title>Communication Backbone Protocols</title>

      <section xml:id="comm-protocols-jid">
	<title>nScreen JID</title>

	<para>
	  All nScreen applications, regardless whether running in server-based
	  or server-less context, are identified using a bare XMPP
	  JID<citation><xref linkend="rfc3920"/></citation>. A single
	  application connection to the nScreen mesh is identified by a fully
	  qualified JID, consisting of a bare JID, identifying the application,
	  and a resource identifier; multiple simultaneous connections by single
	  application are permitted and differentiated by the resource part of
	  the fully qualified JID (an example of a bare JID would be
	  <code>application@somewhere.com</code> while a fully qualified JID
	  would be <code>application@somewhere.com/myimportantdocument</code>.
	</para>

	<para>
	  In the remainder of this document, the term <code>JID</code> is used
	  to refer to bare JIDs; if a fully qualified jabber id is meant, this
	  will always be explicitly stated.
	</para>
      </section>

      <section xml:id="comm-protocols-authentication">
	<title>Authentication</title>

	<para>
	  Authentication is accomplished via SASL per core XMPP protocol
	  (<citation><xref linkend="rfc3920"/></citation>, <citation><xref
	  linkend="rfc2222"/></citation>). SASL authentication must be
	  implemented both for server-based and server-less contexts.
	</para>
      </section>

      <section xml:id="comm-protocols-identity">
	<title>
	  Identity Verification
	</title>

	<section xml:id="comm-protocols-identity-server">
	  <title>Identity Verification in Server-Based Context</title>

	  <para>
	    Standard XMPP does not provide a formal mechanism for identity
	    verification. Because the authentication of two communicating users,
	    <code>A</code> and <code>B</code>, is typically done separately and
	    independently by two different servers, <code>A</code>'s trust in
	    <code>B</code>'s identity implies <code>A</code>'s trust in the
	    authentication procedures of <code>B</code>'s service provider,
	    which cannot be automatically granted.  Therefore, this generic
	    scenario is only acceptable if data exchanged between <code>A</code>
	    and <code>B</code> contains no sensitive information, i.e., for what
	    essentially amounts to an anonymous nScreen service.
	  </para>

	  <para>
	    Though there might be numerous nScreen applications for which an
	    anonymous service is entirely appropriate, an nScreen service that
	    requires reliable identity verification must either implement
	    additional identity verification measures beyond what is specified
	    by the current version of the protocol, or be implemented using a
	    dedicated nScreen server that requires direct login, and does not
	    permit server hops (i.e., both <code>A</code> and <code>B</code> are
	    logging into the same server in order to talk to each other). In
	    this situation the service provider is fully in control of the
	    authentication procedure, and, assuming 1:1 mapping between users
	    and their authentication credentials is in place, successful
	    authentication provides also for identity verification.
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-cloud">
	  <title>Identity Verification in Server-Less Context</title>

	  <para>
	    In server-less context of a home cloud, the 1:1 mapping between
	    nScreen users and authentication credentials cannot be guaranteed; a
	    simple home cloud set up might, for example, rely on a shared secret
	    to allow applications across the cloud to authenticate, which in
	    turn allows an authenticated application to spoof another
	    application.
	  </para>

	  <para>
	    Although identity spoofing carries with it lesser risks in the
	    context of the home cloud, the following measures are required to be
	    taken by compliant nScreen implementations to improve security:

	    <itemizedlist>
	      <listitem>
		<para>
		  Applications must not make assumptions about identity of other
		  nScreen participants in the cloud context, unless they
		  implement additional identity verification procedures not
		  specified by the current version of the nScreen protocol,
		</para>
	      </listitem>

	      <listitem>
		<para>
		  Applications running both in server-based and server-less
		  contexts must not inject data from server-based streams into
		  the cloud and vice versa.
		</para>
	      </listitem>
	    </itemizedlist>
	  </para>
	</section>

	<section xml:id="comm-protocols-identity-future">
	  <title>Future Expectations</title>

	  <para>
	    Additional identity verification mechanism addressing the current
	    limitations, using technologies such as PKI, will be defined in
	    future versions of the protocol.
	  </para>
	</section>
      </section>

      <section xml:id="comm-protocols-subscription">
	<title>Subscription</title>

	<para>
	  The nScreen framework uses a subscription mechanism to provide access
	  control between nScreen applications; the details of the subscription
	  mechanism vary between the server-based and server-less modes of
	  operation.
	</para>

	<section xml:id="comm-protocols-server-subscription">
	  <title>Server-end subscription</title>

	  <para>
	    Server-based nScreen services must implement standard subscription
	    mechanism as set out by the core XMPP protocol<citation><xref
	    linkend="rfc3920"/></citation> and must comply with the subscription
	    policies the core specification sets out.
	  </para>

	  <para>
	    Available outward facing services to which users can subscribe
	    should be advertised by the server via XMPP Service Discovery
	    mechanism <citation><xref linkend="xep0030"/></citation>.
	  </para>
	</section>

	<section xml:id="comm-protocols-local-subscription">
	  <title>Subscription in server-less context</title>

	  <para>
	    The standard, server-centric, XMPP subscription mechanism is not
	    applicable for the link-local set up; in order to circumvent this
	    limitation, the local-nscreen protocol specification defined later
	    in this document (see <xref linkend="local-nscreen"/>), defines a
	    separate subscription mechanism to use in its place.
	  </para>
	</section>

    </section>

    <section xml:id="comm-protocols-privacy">
      <title>Privacy Protocols</title>

      <section xml:id="comm-protocols-privacy-tls">
	<title>TLS</title>

	<para>
	  Compliant nScreen applications, both servers and clients, must
	  support TLS as specified by the core XMPP protocol <citation><xref
	  linkend="rfc3920"/></citation>, and must use TLS secured
	  connections exclusively, both for client-to-server and
	  server-to-server connections; both compliant servers and clients are
	  required to refuse connections that do not use TLS.
	</para>

	<para>
	  It should be noted here again that the use of TLS on its own does not
	  prevent server eavesdropping when the XMPP conversation spans multiple
	  servers. nScreen applications needing to transmit highly sensitive
	  data should either use single-server XMPP exchanges along the lines
	  described in <xref linkend="comm-protocols-identity-server"/>, or
	  otherwise will have to make use of end-to-end encryption.
	</para>

      </section>

      <section xml:id="comm-protocols-privacy-e2e">
	<title>End to end encryption</title>

	<para>
	  The end-to-end encryption to be used by nScreen clients is described
	  by the XMPP e2e extension <citation><xref
	  linkend="rfc3923"/></citation>.

	  <annotation role="comment">
	    <info>
	      <authorinitials>tf</authorinitials>
	      <orgname>Intel</orgname>
	    </info>
	    <para>
	      Ideally, some form of e2e TLS channel for exchange of presence and
	      messages would be preferable, the support for which the XMPP group
	      is looking into<citation><xref
	      linkend="jng-xtls"/></citation>. The xep-e2e will do in principle;
	      it is worth noting that it is unlikely to be used because entities
	      requiring this level of privacy will have to use a dedicated
	      nScreen server for identity verification, in which case TLS
	      provides complete privacy of data in transit by virtue of no
	      server hops being involved, thus rendering e2e superfluous.
	    </para>
	  </annotation>

	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="local-nscreen">
      <title>Link-local nScreen protocol</title>

      <para>
	The link-local nScreen protocol allows for automatic connection between
	nScreen clients running on the same LAN. It is derived from the
	local-xmpp protocol, but with some differences:

	<annotation role="implementation">
	  <info>
	    <authorinitials>wt</authorinitials>
	    <orgname>Collabora</orgname>
	  </info>
	  <para>
	    As far as Salut is concerned, this will be a protocol distinct from
	    local-xmpp.
	  </para>
	</annotation>

	<itemizedlist>
	  <listitem>
	    <para>
	      The link-local service is called 'nscreen' rather than 'presence',
	      i.e., the PTRs have pattern 'JID._nscreen._tcp._local.',
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Connection is done by JID and resource as with regular XMPP; the
	      JID part before the '@' symbol is provided explicitly to the
	      connection manager, the server part after '@' is worked out
	      automatically by the connection manager,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The connection manager implements the subscription mechanism
	      described below (<xref linkend="local-nscreen-subscription"/>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      All implementations must support SASL authentication
	      <citation><xref linkend="rfc2222"/></citation>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <section xml:id="local-nscreen-subscription">
	<title>Subscription mechanism</title>

	<para>
	  Standard XMPP subscription is implemented exchanging
	  <code>&lt;presence/&gt;</code> stanzas. However, the link-local
	  version of XMPP<citation><xref linkend="xep0174"/></citation> uses
	  m-DNS broadcast to distribute presence information, which makes it
	  unsuitable for exchanging client-specific
	  <code>&lt;presence/&gt;</code> stanzas, so a different mechanism for
	  establishing subscription is needed.
	</para>

	<para>
	  At the same time, it is desirable that the alternative subscription
	  mechanism would be functionally equivalent to standard XMPP
	  subscription so that any user-level APIs could be identical for both
	  the server-based and server-less scenarios. To this end, the
	  local-nscreen protocol defines a thin layer allowing the relevant
	  <code>&lt;presence/&gt;</code> stanzas to be delivered independently
	  of the m-DNS presence broadcasts.
	</para>

	<para>
	  The local-nscreen subscription handshake is carried out by exchanging
	  <code>&lt;iq/&gt;</code> <code>set</code> stanzas using
	  <code>urn:nscreen:local-subscription</code> namespace. These
	  <code>&lt;iq/&gt;</code> stanzas provide a wrapper around appropriate
	  <code>&lt;presence/&gt;</code> stanzas as used by the standard XMPP
	  subscription mechanism, so that a local-nscreen subscription exchange
	  can be converted into a standard XMPP subscription exchange by simply
	  stripping out the external <code>&lt;iq/&gt;</code> layer.
	</para>

	<para>
	  Compliant local-nscreen connection managers are required to implement
	  this mechanism.
	</para>

<annotation role='implementation'>
  <info>
    <authorinitials>tf</authorinitials>
    <orgname>Intel</orgname>
  </info>
  <para>
    The initial Telepathy implementation of this protocol might not implement
    this functionality, deferring it to a second iteration; based on the
    experiences with the initial implementation, this, and other, parts of this
    specification might need to be tuned.
  </para>
</annotation>
      </section>
  </section>

  <?hard-pagebreak?>
  <section xml:id="messaging">
    <title>Messaging Protocols</title>

    <section xml:id="messaging-app-info">
      <title>Descriptive Application Information</title>

      <para>
	nScreen applications need to provide descriptive information about
	themselves that can be presented to the user. At the bare minimum, this
	information includes a suitable, localised, application name.
      </para>
      <para>
	The mechanism for obtaining descriptive application information is XMPP
	Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>; the descriptive information is contained
	in a <code>&lt;identity/&gt;</code> element of <code>category</code>
	'client'. Two new types are defined for use with this category:
	<code>'nscreen-application'</code> and
	<code>'nscreen-controller'</code>, corresponding to task-oriented and
	control applications respectively (see <xref
	linkend="intro-application-classes"/>).
      </para>

      <para>
	The <code>name</code> attribute of the <code>&lt;identity/&gt;</code>
	element holds application name, while the <code>xml:lang</code>
	attribute identifies the locale used by the <code>name</code>
	attribute. As per XMPP Service Discovery extension<citation><xref
	linkend="xep0030"/></citation>, the query reply may include multiple
	<code>&lt;identity/&gt;</code> elements of the same category and type,
	but with different <code>xml:lang</code> attribute.
      </para>

      <para>
	If the <code>&lt;query/&gt;</code> of the original request has an
	explicit <code>xml:lang</code> attribute, the reply contents should be
	filtered by that attribute. If the <code>xml:lang</code> attribute of
	the <code>&lt;query/&gt;</code> cannot be matched the respondent may
	return either a suitable fall-back, or all available translations.
      </para>

      <para>
	(For full description of the XML elements, see <xref
	linkend="appendix-schemas"/>).
      </para>

      <example xml:id="messaging-app-info-example">
	<title>Application Information XML example</title>

	<programlisting language="xml"><![CDATA[
<iq to="icecream-maker@custom-foods.com/resource"
    type="get"
    id="appinfo1">

  <query xmlns='http://jabber.org/protocol/disco#info'/
         xml:lang="en-GB"/>

</iq>

 ...

<iq to="a.customer@custom-foods.com/resource"
    type="result"
    id="appinfo1">

  <identity category='client'
            type='nscreen-application'
            name='Magic Icecream Maker'
	    xml:lang='en-GB'/>

</iq>]]>
	</programlisting>
      </example>

    </section>

    <section xml:id="messaging-app-caps">
      <title>Application Capabilities</title>

      <para>
	nScreen applications must advertise their nScreen capabilities via XMPP
	Entity Capabilities protocol<citation><xref
	linkend="xep0115"/></citation>, using
	<code>urn:nscreen:capabilities</code> as the value of the
	<code>node</code> attribute of the <code>&lt;c/&gt;</code> element.
      </para>

      <para>
	Each individual nScreen capability is represented by the
	<code>&lt;feature/&gt;</code> element; the <code>var</code> attribute is
	constructed by concatenating an <code>'urn:nscreen:capabilies:'</code>
	prefix and the canonical name of the capability (for standard
	capabilities defined in <xref linkend="messaging-metadata-caps"/>).
      </para>

      <para>
	In addition, nScreen applications should also advertise any data
	transfer protocols they support as above, using the <code>urn</code>s
	defined in <xref linkend="messaging-data-transfer-urns"/> as the value
	of the <code>var</code> attribute. For example, an application
	supporting video playback capability and able to stream files via Jingle
	RTP would be represented as:
      </para>

      <programlisting><![CDATA[
<c node='urn:nscreen:capabilities'>
  <feature var='urn:nscreen:capabilities:ns-caps-video' />
  <feature var='urn:nscreen:data:jingle:rtp' />
<c/>
]]></programlisting>
    </section>

    <section xml:id="messaging-status">
      <title>Extended Status</title>

      <para>
	Extended status information is advertised using XMPP Personal Eventing
	Protocol<citation><xref linkend="xep0163"/></citation>. The status
	payload is held by an <code>&lt;nscreen:status/&gt;</code> element and
	its attributes; applications with multiple capabilities must include
	an <code>&lt;nscreen:status/&gt;</code> element for each capability.
      </para>

      <para>
	The following attributes, in addition to those defined in <xref
	linkend="messaging-metadata-attributes"/>, are used with the
	<code>&lt;nscreen:status/&gt;</code> element:

	<variablelist>
	  <varlistentry>
	    <term><code>version</code></term>

	    <listitem>
	      <para>
		nScreen protocol version; required,
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>capability</code></term>

	    <listitem>
	      <para>
		The capability this status applies to; required. The value
		should be preferably one of those defined in <xref
		linkend="messaging-metadata-caps"/>,
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>activity</code></term>

	    <listitem>
	      <para>
		The activity this status represents; optional (if not present
		<code>ns-activity-idle</code> is implied). The value should be
		preferably one of those defined in <xref
		linkend="messaging-metadata-activity"/>
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><code>primary-capability</code></term>

	    <listitem>
	      <para>
		Boolean indicating whether capability this status applies to is
		the primary capability of the application; optional (if absent
		<code>false</code> is implied).
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>
      </para>

      <para>
	While the <code>&lt;nscreen:status/&gt;</code> element can be extended
	with custom attributes, no frequently changing information
	(such as current playback position) is permitted as part of status to
	avoid flooding of the network.
      </para>

      <para>
	Human readable description is provided using one or more
	<code>&lt;nscreen:description/&gt;</code> elements inside the
	<code>&lt;nscreen:status/&gt;</code> element; each
	<code>&lt;nscreen:description/&gt;</code> element must have an
	<code>xml:lang</code> attribute, and multiple
	<code>&lt;nscreen:description/&gt;</code> elements must have a different
	<code>xml:lang</code> attribute each.
      </para>

	<example xml:id="messaging-status-example">
	  <title>Status XML example</title>

	  <programlisting><![CDATA[
<nscreen:status version='1.0'
                capability='ns-caps-video'
                activity='ns-activity-play'
                uri='some random youtube url'
                volume='0.75'>
  <nscreen:description xml:lang='en-GB'>
    Playing a video about colour-based optical illusions.
  </nscreen:description>
</nscreen:status>]]>
	  </programlisting>
	</example>

      <section xml:id="messaging-status-avatars">
	<title>Support for Avatars</title>

	<para>
	  In addition to the extended status mechanism described above, it is
	  recommended that all nScreen implementations support the XMPP User
	  Avatar specification<citation><xref linkend="xep0084"/></citation>.
	</para>
      </section>
    </section>

    <section xml:id="messaging-commands">
      <title>Instruction Messages</title>

      <para>
	Instruction messages are used to send nScreen commands and information
	queries. The protocol defines a set of generic XML elements that are
	used to encapsulate such messages, with parameters transmitted via
	XML attributes.
      </para>

      <para>
	The messages are exchanged using XMPP <code>&lt;iq/&gt;</code>
	stanzas, using the <code>urn:nscreen:messages</code> namespace:

	<itemizedlist>
	  <listitem>
	    <para>
	      Commands are dispatched using <code>&lt;iq/&gt;</code> stanza of
	      type <code>set</code>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Information requests are sent using type <code>get</code>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      All <code>get</code> / <code>set</code> requests must be
	      acknowledged by the recipient using <code>&lt;iq/&gt;</code>
	      stanzas of type <code>result</code> or <code>error</code>,
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Error handling is done via <code>&lt;iq/&gt;</code> stanzas of
	      type <code>error</code>, using the stanza error protocol
	      (<code>urn:ietf:params:xml:ns:xmpp-stanzas</code>) defined by XMPP
	      core <citation><xref linkend="rfc3920"/></citation>. Additional,
	      application specific information can be included as per the
	      core protocol.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>


      <section xml:id="messaging-commands-iq-set">
	<title>Commands</title>

	<para>
	  Commands use <code>set</code> type <code>&lt;iq/&gt;</code> stanzas;
	  the command payload is carried by one of the XML elements defined
	  below.
	</para>

	<section xml:id="messaging-commands-command">
	  <title><code>&lt;nscreen:command/&gt;</code></title>

	  <para>
	    A command sent from application <code>A</code> to application
	    <code>B</code> to executed directly by application <code>B</code>.
	  </para>
	  <para>
	    Required attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>version</code>
		</term>
		<listitem>
		  <para>
		    The nScreen protocol version,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>capability</code>
		</term>
		<listitem>
		  <para>
		    Capability on which the command is to operate, preferably
		    using one of the values defined in <xref
		    linkend="messaging-metadata-caps"/>,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>activity</code>
		</term>
		<listitem>
		  <para>
		    Activity to carry out, preferably using one of the values
		    defined in <xref linkend="messaging-metadata-activity"/>,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>time</code>
		</term>
		<listitem>
		  <para>
		    Time of command dispatch with at least millisecond
		    precision, in standard XMPP format<citation><xref
		    linkend="xep0082"/></citation>.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Additional attributes, preferably using those defined in <xref
	    linkend="messaging-metadata-attributes"/>, are used to further
	    qualify the capability and activity specified.
	  </para>

	  <section xml:id="messaging-commands-command-error">
	    <title>Error handling</title>
	    <para>
	      When the resource to which the nScreen command pertains is
	      unavailable, the command recipient should return an error that
	      best describes reason why:

	      <variablelist>
		<varlistentry>
		  <term><code>&lt;forbidden/&gt;</code></term>
		  <listitem>
		    <para>
		      The recipient does not have sufficient privileges to
		      carry out the command.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><code>&lt;item-not-found/&gt;</code></term>
		  <listitem>
		    <para>
		      The resource could not be located.
		    </para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </para>
	    <para>
	      The <code>type</code> attribute of the
	      <code>&lt;error/&gt;</code> stanza should be set appropriately:
	      the <code>modify</code> value should be used if the recipient is
	      able to explore other sources for the same resource; the value
	      <code>cancel</code> is used to indicate that no further attempts
	      to execute this command should be made.
	    </para>

	    <para>
	      When handling errors of type <code>modify</code>, the sender must
	      explore each possible source no more than once. When all known
	      sources are exhausted, the initiating application should notify
	      user that the command could not be executed.
	    </para>
	  </section>
	</section>

	<section xml:id="messaging-commands-transfer">
	  <title><code>&lt;nscreen:transfer/&gt;</code></title>

	  <para>
	    A request by application <code>A</code> to application
	    <code>B</code> to transfer <code>B</code>'s activity to application
	    <code>C</code>.
	  </para>

	  <para>
	    Required attributes:

	    <variablelist>
	      <varlistentry>
		<term>
		  <code>version</code>
		</term>
		<listitem>
		  <para>
		    The nScreen protocol version,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>capability</code>
		</term>
		<listitem>
		  <para>
		    Capability that is subject of the transfer,
		  </para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term>
		  <code>jid</code>
		</term>
		<listitem>
		  <para>
		    JID of the application to transfer to.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </para>

	  <para>
	    Additional attributes, preferably using those defined in <xref
	    linkend="messaging-metadata-attributes"/>, may be used to further
	    qualify the capability specified.
	  </para>

	</section>

      </section>

      <section xml:id="messaging-commands-iq-get">
	<title>Information requests</title>

	<para>
	  Information requests use <code>get</code> type
	  <code>&lt;iq/&gt;</code> stanzas; the command payload is carried by
	  one of the following XML elements:
	</para>

	<section xml:id="messaging-commands-find">
	  <title><code>&lt;nscreen:find/&gt;</code></title>

	  <para>
	    A request by an application <code>A</code> to a control application
	    <code>C</code> to identify a suitable application <code>B</code> to
	    dispatch a (subsequent) command to:

	    <itemizedlist>
	      <listitem>
		<para>
		  The criteria for the search is given by the supplied
		  attributes, (e.g., application capability would be specified
		  using the <code>capability</code> attribute),
		</para>
	      </listitem>

	      <listitem>
		<para>
		  The search is limited to the service context the control
		  application is part of, or, in the case of the home cloud, the
		  device the control application is running on,
		</para>
	      </listitem>
	      <listitem>
		<para>
		  The control application returns the result of the search using
		  the <code>&lt;nscreen:find-result/&gt;</code> element (see
		  <xref linkend="messaging-commands-find-result"/>).
		</para>
	      </listitem>
	    </itemizedlist>
	  </para>

<annotation role='comment'>
  <info>
    <authorinitials>tf</authorinitials>
    <orgname>Intel</orgname>
  </info>
  <para>
    Rationale: because of the need to
    facilitate e2e encryption, commands cannot be proxied through
    control applications; the <code>find</code> request allows
    clients to initiate a transfer to an application that might
    not yet be running on the target device.
  </para>

  <para>
    Not allowing proxying of commands via intermediate applications also
    significantly simplifies issues related to access control.
  </para>
</annotation>

	  <section xml:id="messaging-commands-find-error">
	    <title>Error handling</title>

	    <para>
	      If no suitable running application matching the specified criteria
	      can be identified but a suitable application is available on the
	      system, the control application must return immediately an error
	      of type <code>wait</code>, then attempt to start such suitable
	      application.
	    </para>

	    <para>
	      If a suitable application does not exist on the system, the
	      control application must return immediately error of type
	      <code>cancel</code> and an error condition
	      <code>&lt;item-not-found/&gt;</code>.
	    </para>

	    <para>
	      When the spawned client application successfully starts up, the
	      control application must dispatch the
	      <code>&lt;nscreen:find-result/&gt;</code> response, with an
	      identical <code>id</code> attribute of the
	      <code>&lt;iq/&gt;</code> query. If the application fails to start,
	      the control application must dispatch error of type
	      <code>cancel</code>, again with an identical <code>id</code>
	      attribute of the <code>&lt;iq/&gt;</code> query; the error
	      condition should indicate why the application failed to start, if
	      that is known.
	    </para>

	    <para>
	      An application that receives an <code>&lt;error/&gt;</code> of
	      type <code>wait</code> in response to
	      <code>&lt;nscreen:find/&gt;</code> request should wait for further
	      communication from the recipient (either result or error); the
	      sender must not resend the original request in response to the
	      <code>wait</code> error (NB: this is a departure from the regular
	      semantics of XMPP <code>wait</code> errors).
	    </para>
	  </section>

	</section>
      </section>

      <section xml:id="messaging-commands-iq-result">
	<title>Replies</title>

	<para>
	  All received <code>set</code> and <code>get</code> nScreen message
	  queries must be explicitly acknowledged by the recipient:

	  <itemizedlist>
	    <listitem>
	      <para>
		Failure is indicated using an <code>&lt;iq/&gt;</code> stanza of
		type <code>error</code>,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Success is indicated by a stanza of type <code>result</code>,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Depending on the nature of the original query, a returned
		<code>result</code> stanza might, or might not hold additional
		information using one of the following XML elements.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>

	<section xml:id="messaging-commands-find-result">
	  <title><code>&lt;nscreen:find-result/&gt;</code></title>

	  <para>
	    Reply to a previous <code>find</code> query that was successfully
	    resolved. The identified application JID is stored in the
	    required <code>jid</code> attribute.
	  </para>

    <example xml:id="messaging-commands-example">
      <title>Command example</title>

      <para>
	The following XML snippet tells some other application to start
	playing given video starting 3/4 into the video duration:
      </para>

      <programlisting><![CDATA[
<iq type='set'
    id='command1'
    to='magic-video-player@blackbox.local'
    xmlns='urn:nscreen:messages'>

  <nscreen:command version='1.0'
                   time='1970-01-01T00:00:00.000Z'
                   capability='ns-caps-video'
                   activity='ns-activity-play'
                   uri='some random youtube url'
                   progress='0.75'>
        [Optional command data; binary data base64 encoded]
  </nscreen:command>
</iq>

 ...

<iq type='result'
    id='command1'
    to='the-other-player@bluebox.local'
    from='magic-video-player@blackbox.local'
    xmlns='urn:nscreen:messages'/>]]>
      </programlisting>
    </example>

	</section>
      </section>
    </section>

    <section xml:id="messaging-metadata">
      <title>Common meta-data classes</title>

      <para>
	The canonical definition is given in <xref linkend="appendix-schemas"/>;
	the following information is extracted from the XML schemas for
	convenience.
      </para>


      <section xml:id="messaging-metadata-caps">
	<title>Common capability classes</title>

	<para>
	  <variablelist>
	    <varlistentry>
	      <term>
		<code>ns-caps-control</code>
	      </term>

	      <listitem>
		<para>
		  control application,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-audio</code>
	      </term>

	      <listitem>
		<para>
		  audio playback capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-video</code>
	      </term>

	      <listitem>
		<para>
		  video playback capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-image</code>
	      </term>

	      <listitem>
		<para>
		  image display capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-html</code>
	      </term>

	      <listitem>
		<para>
		  html rendering capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-caps-antivirus</code>
	      </term>

	      <listitem>
		<para>
		  anti-virus capabilities,
		</para>
	      </listitem>
	    </varlistentry>

	  </variablelist>
	</para>

	<annotation role='comment'>
	    <info>
	      <authorinitials>tf</authorinitials>
	      <orgname>Intel</orgname>
	    </info>
	    <para>
	      More standard definitions should be added here; open to
	      suggestions.
	    </para>
	  </annotation>

	<para>
	  Custom capabilities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom capabilities must not use
	  'ns-' prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-activity">
	<title>Common activity classes</title>

	<para>
	  Absence of the 'activity' attribute, or its empty value, imply idle
	  state.

	  <variablelist>
	    <varlistentry>
	      <term>
		<code>ns-activity-playback</code>
	      </term>

	      <listitem>
		<para>
		  playback,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-pause</code>
	      </term>
	      <listitem>
		<para>
		  paused state,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-ffw</code>
	      </term>
	      <listitem>
		<para>
		  fast forward,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-rwd</code>
	      </term>
	      <listitem>
		<para>
		  rewind,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-scan</code>
	      </term>
	      <listitem>
		<para>
		  scan,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		<code>ns-activity-volume</code>
	      </term>
	      <listitem>
		<para>
		  volume adjustment.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<annotation role='comment'>
	  <info>
	    <authorinitials>tf</authorinitials>
	    <orgname>Intel</orgname>
	  </info>
	  <para>
	  More standard definitions should be added here, open to suggestions.
	  </para>
	</annotation>

	<para>
	  Custom activities can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom activities must not use 'ns-'
	  prefix.
	</para>
      </section>

      <section xml:id="messaging-metadata-attributes">
	<title>Common attributes</title>

	<para>
	  <variablelist>
	    <varlistentry>
	      <term><code>protocol</code></term>

	      <listitem>
		<para>
		  <code>urn</code> identifying a suitable protocol through which
		  the resource on which to operate can be obtained (see <xref
		  linkend="messaging-data-transfer-urns"/>). Multiple protocols
		  can be listed as a space separated list, in descending order
		  of preference.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>uri</code></term>

	      <listitem>
		<para>
		  <code>uri</code> a of a resource associated with activity.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>uid</code></term>

	      <listitem>
		<para>
		  Universal id identifying resource associated with activity,

		<annotation role='comment'>
		  <info>
		    <authorinitials>tf</authorinitials>
		    <orgname>Intel</orgname>
		  </info>
		  <para>
		    The idea is being able to use something like, for example,
		    musicbrainz id to identify the resource, though in practice
		    this might be hard to extend beyond audio
		  </para>
		</annotation>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>volume</code></term>

	      <listitem>
		<para>
		  volume level (floating point number from &lt;0,1&gt;),
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>progress</code></term>

	    <listitem>
	      <para>
		activity progress (floating point number from
		&lt;0,1&gt; this is the preferred way of passing information
		such as stream position,
	      </para>
	    </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>position</code></term>

	      <listitem>
		<para>
		  activity position (floating point number); NB: applications
		  should use the <code>progress</code> attribute whenever
		  possible instead of 'position',
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>description</code></term>

	      <listitem>
		<para>
		  description: human readable description, suitable for
		  presentation to user,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jid</code></term>

	      <listitem>
		<para>
		  XMPP id,
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>speed</code></term>

	      <listitem>
		<para>
		  speed of activity (floating point number; 1.0 indicates
		  normal speed).
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>

	<para>
	  Custom attributes can be defined, providing these are suitably
	  name-spaced with a custom prefix; custom attributes must not use 'ns-'
	  prefix.
	</para>
      </section>

    </section>
    <section xml:id="messaging-data-transfer">
      <title>Data Transfer Protocols</title>

      <para>
	This section defines standard data transfer protocols to be used by
	nScreen clients; this list does not restrict clients to these protocols
	alone, but sets out preferred protocols.
      </para>

      <section xml:id="messaging-data-transfer-files">
	<title>File Transfers</title>

	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		The preferred file transfer protocol is SI File
		Transfer<citation><xref linkend="xep0096"/></citation>; this
		protocol must be supported by all compliant nScreen clients for
		which a <code>file</code> constitutes a meaningful data unit,
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		It is recommended that clients also implement Jingle
		File Transfer<citation><xref linkend="xep0234"/></citation>;
		this protocol is currently in experimental stage, but once it is
		reaches the draft stage, it will be adopted as the default file
		transfer protocol for nScreen clients.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </section>

      <section xml:id="messaging-data-transfer-streaming">
	<title>Streaming</title>

	<para>
	  The preferred streaming protocol is XMPP Jingle RTP<citation><xref
	  linkend="xep0167"/></citation>; applications that support media
	  streaming should implement this protocol.
	</para>
      </section>

      <section xml:id="messaging-data-transfer-urns">
	<title>URNs for common resource fetching protocols</title>

	<para>
	  This section codifies <code>urn</code>s to be used with the
	  <code>uri</code> attribute of nScreen commands to indicate how to
	  reach the resource, and when advertising application capabilities (see
	  <xref linkend="messaging-app-caps"/>). Each <code>urn</code> is formed
	  by combining a '<code>urn:nscreen:data:</code>' prefix with one of the
	  protocol ids defined below:
	</para>
	<para>
	  <variablelist>
	    <varlistentry>
	      <term><code>si-file</code></term>

	      <listitem>
		<para>
		  Resource can be obtained from initiating application using SI
		  File Transfer<citation><xref linkend="xep0096"/></citation>,
		  see <xref linkend="messaging-data-transfer-files"/>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jingle:ft</code></term>

	      <listitem>
		<para>
		  Resource can be obtained from initiating application using
		  XMPP Jingle File Transfer<citation><xref
		  linkend="xep0234"/></citation>, see <xref
		  linkend="messaging-data-transfer-files"/>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>jingle:rtp</code></term>

	      <listitem>
		<para>
		  Resource can be obtained from initiating application using
		  XMPP Jingle RTP<citation><xref linkend="xep0167"/></citation>,
		  see <xref linkend="messaging-data-transfer-streaming"/>
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><code>upnp-av</code></term>

	      <listitem>
		<para>
		  Resource can be obtained using UPnP AV protocols.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</para>
      </section>
    </section>
  </section>

  <?hard-pagebreak?>
  <appendix xml:id="appendix-schemas">
    <title>nScreen XML Schemas</title>

    <section xml:id="appendix-schemas-nscreen-subscription">
      <title>Schema for <code>urn:nscreen:local-subscription</code></title>
      <programlisting><!-- The xi:include line must be aligned directly at the
			   end of this comment, as any padding will end up in
			   the final document !!!
		      --><xi:include
	     parse="text"
	     href="./nscreen-protocol-subscription.xsd" /></programlisting>
    </section>

    <section xml:id="appendix-schemas-nscreen-status">
      <title>Schema for <code>urn:nscreen:status</code></title>
      <programlisting><!-- The xi:include line must be aligned directly at the
			   end of this comment, as any padding will end up in
			   the final document !!!
		      --><xi:include
	     parse="text"
	     href="./nscreen-protocol-status.xsd" /></programlisting>
    </section>

    <section xml:id="appendix-schemas-nscreen-messages">
      <title>Schema for <code>urn:nscreen:messages</code></title>
      <programlisting><!-- The xi:include line must be aligned directly at the
			   end of this comment, as any padding will end up in
			   the final document !!!
		      --><xi:include
	     parse="text"
	     href="./nscreen-protocol-messages.xsd" /></programlisting>
    </section>
  </appendix>

  <?hard-pagebreak?>
  <bibliography>
    <title>External Resources</title>
    <bibliodiv>
    <title></title>

    <biblioentry xml:id="rfc3920">
      <title>RFC 3920</title>
      <subtitle>Extensible Messaging and Presence Protocol (XMPP):
      Core</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://tools.ietf.org/html/rfc3920"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="rfc3921">
      <title>RFC 3921</title>
      <subtitle>Extensible Messaging and Presence Protocol (XMPP): Instant
      Messaging and Presence</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://tools.ietf.org/html/rfc3921"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="rfc2222">
      <title>RFC 2222</title>
      <subtitle>Simple Authentication and Security Layer (SASL)</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource>
	<link xlink:href="http://tools.ietf.org/html/rfc2222"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="rfc3923">
      <title>RFC 3923</title>
      <subtitle>End-to-End Signing and Object Encryption for the Extensible
      Messaging and Presence Protocol (XMPP)</subtitle>
      <publishername>The Internet Engineering Task Force</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://tools.ietf.org/html/rfc3923"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0030">
      <title>XEP-0030</title>
      <subtitle>Service Discovery</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0030.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0060">
      <title>XEP-0060</title>
      <subtitle>Publish-Subscribe</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0060.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0082">
      <title>XEP-0082</title>
      <publishername>XMPP Standards Foundation</publishername>
      <subtitle>XMPP Date and Time Profiles</subtitle>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0082.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0084">
      <title>XEP-0084</title>
      <subtitle>User Avatar</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0084.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0096">
      <title>XEP-0096</title>
      <subtitle>SI File Transfer</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0096.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0115">
      <title>XEP-0115</title>
      <subtitle>Entity Capabilities</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0115.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0163">
      <title>XEP-0163</title>
      <subtitle>Personal Eventing Protocol</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0163.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0166">
      <title>XEP-0166</title>
      <subtitle>Jingle</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0166.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0167">
      <title>XEP-0167</title>
      <subtitle>Jingle RTP Sessions</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0167.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0174">
      <title>XEP-0174</title>
      <subtitle>Serverless Messaging</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0174.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="xep0234">
<!--
      <author>
	<personname>
	  <firstname>Peter</firstname>
	  <surname>Saint-Andre</surname>
	</personname>
      </author>
-->
      <title>XEP-0234</title>
      <subtitle>Jingle File Transfer</subtitle>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/xep-0234.html"/>
      </bibliosource>
    </biblioentry>

    <biblioentry xml:id="jng-xtls">
      <title>Jingle XTLS</title>
      <publishername>XMPP Standards Foundation</publishername>
      <bibliosource class="uri">
	<link xlink:href="http://xmpp.org/extensions/inbox/jingle-xtls.html"/>
      </bibliosource>
    </biblioentry>

    </bibliodiv>
  </bibliography>
</article>
